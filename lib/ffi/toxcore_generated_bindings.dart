// ignore_for_file: camel_case_types, non_constant_identifier_names, constant_identifier_names
import 'proxy.dart' as ffi;

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.

/// Bindings to toktok/c-toxcore
class ToxFfi {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  ToxFfi(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  ToxFfi.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  int tox_version_major() {
    return _tox_version_major();
  }

  late final _tox_version_majorPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function()>>('tox_version_major');
  late final _tox_version_major =
      _tox_version_majorPtr.asFunction<int Function()>();

  int tox_version_minor() {
    return _tox_version_minor();
  }

  late final _tox_version_minorPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function()>>('tox_version_minor');
  late final _tox_version_minor =
      _tox_version_minorPtr.asFunction<int Function()>();

  int tox_version_patch() {
    return _tox_version_patch();
  }

  late final _tox_version_patchPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function()>>('tox_version_patch');
  late final _tox_version_patch =
      _tox_version_patchPtr.asFunction<int Function()>();

  /// Return whether the compiled library version is compatible with the passed
  /// version numbers.
  bool tox_version_is_compatible(
    int major,
    int minor,
    int patch,
  ) {
    return _tox_version_is_compatible(
          major,
          minor,
          patch,
        ) !=
        0;
  }

  late final _tox_version_is_compatiblePtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint8 Function(ffi.Uint32, ffi.Uint32,
              ffi.Uint32)>>('tox_version_is_compatible');
  late final _tox_version_is_compatible =
      _tox_version_is_compatiblePtr.asFunction<int Function(int, int, int)>();

  int tox_public_key_size() {
    return _tox_public_key_size();
  }

  late final _tox_public_key_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function()>>('tox_public_key_size');
  late final _tox_public_key_size =
      _tox_public_key_sizePtr.asFunction<int Function()>();

  int tox_secret_key_size() {
    return _tox_secret_key_size();
  }

  late final _tox_secret_key_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function()>>('tox_secret_key_size');
  late final _tox_secret_key_size =
      _tox_secret_key_sizePtr.asFunction<int Function()>();

  int tox_conference_uid_size() {
    return _tox_conference_uid_size();
  }

  late final _tox_conference_uid_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function()>>(
          'tox_conference_uid_size');
  late final _tox_conference_uid_size =
      _tox_conference_uid_sizePtr.asFunction<int Function()>();

  int tox_conference_id_size() {
    return _tox_conference_id_size();
  }

  late final _tox_conference_id_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function()>>(
          'tox_conference_id_size');
  late final _tox_conference_id_size =
      _tox_conference_id_sizePtr.asFunction<int Function()>();

  int tox_nospam_size() {
    return _tox_nospam_size();
  }

  late final _tox_nospam_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function()>>('tox_nospam_size');
  late final _tox_nospam_size =
      _tox_nospam_sizePtr.asFunction<int Function()>();

  int tox_address_size() {
    return _tox_address_size();
  }

  late final _tox_address_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function()>>('tox_address_size');
  late final _tox_address_size =
      _tox_address_sizePtr.asFunction<int Function()>();

  int tox_max_name_length() {
    return _tox_max_name_length();
  }

  late final _tox_max_name_lengthPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function()>>('tox_max_name_length');
  late final _tox_max_name_length =
      _tox_max_name_lengthPtr.asFunction<int Function()>();

  int tox_max_status_message_length() {
    return _tox_max_status_message_length();
  }

  late final _tox_max_status_message_lengthPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function()>>(
          'tox_max_status_message_length');
  late final _tox_max_status_message_length =
      _tox_max_status_message_lengthPtr.asFunction<int Function()>();

  int tox_max_friend_request_length() {
    return _tox_max_friend_request_length();
  }

  late final _tox_max_friend_request_lengthPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function()>>(
          'tox_max_friend_request_length');
  late final _tox_max_friend_request_length =
      _tox_max_friend_request_lengthPtr.asFunction<int Function()>();

  int tox_max_message_length() {
    return _tox_max_message_length();
  }

  late final _tox_max_message_lengthPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function()>>(
          'tox_max_message_length');
  late final _tox_max_message_length =
      _tox_max_message_lengthPtr.asFunction<int Function()>();

  int tox_max_custom_packet_size() {
    return _tox_max_custom_packet_size();
  }

  late final _tox_max_custom_packet_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function()>>(
          'tox_max_custom_packet_size');
  late final _tox_max_custom_packet_size =
      _tox_max_custom_packet_sizePtr.asFunction<int Function()>();

  int tox_hash_length() {
    return _tox_hash_length();
  }

  late final _tox_hash_lengthPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function()>>('tox_hash_length');
  late final _tox_hash_length =
      _tox_hash_lengthPtr.asFunction<int Function()>();

  int tox_file_id_length() {
    return _tox_file_id_length();
  }

  late final _tox_file_id_lengthPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function()>>('tox_file_id_length');
  late final _tox_file_id_length =
      _tox_file_id_lengthPtr.asFunction<int Function()>();

  int tox_max_filename_length() {
    return _tox_max_filename_length();
  }

  late final _tox_max_filename_lengthPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function()>>(
          'tox_max_filename_length');
  late final _tox_max_filename_length =
      _tox_max_filename_lengthPtr.asFunction<int Function()>();

  int tox_max_hostname_length() {
    return _tox_max_hostname_length();
  }

  late final _tox_max_hostname_lengthPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function()>>(
          'tox_max_hostname_length');
  late final _tox_max_hostname_length =
      _tox_max_hostname_lengthPtr.asFunction<int Function()>();

  bool tox_options_get_ipv6_enabled(
    ffi.Pointer<Tox_Options> options,
  ) {
    return _tox_options_get_ipv6_enabled(
          options,
        ) !=
        0;
  }

  late final _tox_options_get_ipv6_enabledPtr =
      _lookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<Tox_Options>)>>(
          'tox_options_get_ipv6_enabled');
  late final _tox_options_get_ipv6_enabled = _tox_options_get_ipv6_enabledPtr
      .asFunction<int Function(ffi.Pointer<Tox_Options>)>();

  void tox_options_set_ipv6_enabled(
    ffi.Pointer<Tox_Options> options,
    bool ipv6_enabled,
  ) {
    return _tox_options_set_ipv6_enabled(
      options,
      ipv6_enabled ? 1 : 0,
    );
  }

  late final _tox_options_set_ipv6_enabledPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<Tox_Options>,
              ffi.Uint8)>>('tox_options_set_ipv6_enabled');
  late final _tox_options_set_ipv6_enabled = _tox_options_set_ipv6_enabledPtr
      .asFunction<void Function(ffi.Pointer<Tox_Options>, int)>();

  bool tox_options_get_udp_enabled(
    ffi.Pointer<Tox_Options> options,
  ) {
    return _tox_options_get_udp_enabled(
          options,
        ) !=
        0;
  }

  late final _tox_options_get_udp_enabledPtr =
      _lookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<Tox_Options>)>>(
          'tox_options_get_udp_enabled');
  late final _tox_options_get_udp_enabled = _tox_options_get_udp_enabledPtr
      .asFunction<int Function(ffi.Pointer<Tox_Options>)>();

  void tox_options_set_udp_enabled(
    ffi.Pointer<Tox_Options> options,
    bool udp_enabled,
  ) {
    return _tox_options_set_udp_enabled(
      options,
      udp_enabled ? 1 : 0,
    );
  }

  late final _tox_options_set_udp_enabledPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<Tox_Options>,
              ffi.Uint8)>>('tox_options_set_udp_enabled');
  late final _tox_options_set_udp_enabled = _tox_options_set_udp_enabledPtr
      .asFunction<void Function(ffi.Pointer<Tox_Options>, int)>();

  bool tox_options_get_local_discovery_enabled(
    ffi.Pointer<Tox_Options> options,
  ) {
    return _tox_options_get_local_discovery_enabled(
          options,
        ) !=
        0;
  }

  late final _tox_options_get_local_discovery_enabledPtr =
      _lookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<Tox_Options>)>>(
          'tox_options_get_local_discovery_enabled');
  late final _tox_options_get_local_discovery_enabled =
      _tox_options_get_local_discovery_enabledPtr
          .asFunction<int Function(ffi.Pointer<Tox_Options>)>();

  void tox_options_set_local_discovery_enabled(
    ffi.Pointer<Tox_Options> options,
    bool local_discovery_enabled,
  ) {
    return _tox_options_set_local_discovery_enabled(
      options,
      local_discovery_enabled ? 1 : 0,
    );
  }

  late final _tox_options_set_local_discovery_enabledPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<Tox_Options>,
              ffi.Uint8)>>('tox_options_set_local_discovery_enabled');
  late final _tox_options_set_local_discovery_enabled =
      _tox_options_set_local_discovery_enabledPtr
          .asFunction<void Function(ffi.Pointer<Tox_Options>, int)>();

  int tox_options_get_proxy_type(
    ffi.Pointer<Tox_Options> options,
  ) {
    return _tox_options_get_proxy_type(
      options,
    );
  }

  late final _tox_options_get_proxy_typePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<Tox_Options>)>>(
          'tox_options_get_proxy_type');
  late final _tox_options_get_proxy_type = _tox_options_get_proxy_typePtr
      .asFunction<int Function(ffi.Pointer<Tox_Options>)>();

  void tox_options_set_proxy_type(
    ffi.Pointer<Tox_Options> options,
    int type,
  ) {
    return _tox_options_set_proxy_type(
      options,
      type,
    );
  }

  late final _tox_options_set_proxy_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<Tox_Options>,
              ffi.Int32)>>('tox_options_set_proxy_type');
  late final _tox_options_set_proxy_type = _tox_options_set_proxy_typePtr
      .asFunction<void Function(ffi.Pointer<Tox_Options>, int)>();

  ffi.Pointer<ffi.Int8> tox_options_get_proxy_host(
    ffi.Pointer<Tox_Options> options,
  ) {
    return _tox_options_get_proxy_host(
      options,
    );
  }

  late final _tox_options_get_proxy_hostPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int8> Function(
              ffi.Pointer<Tox_Options>)>>('tox_options_get_proxy_host');
  late final _tox_options_get_proxy_host = _tox_options_get_proxy_hostPtr
      .asFunction<ffi.Pointer<ffi.Int8> Function(ffi.Pointer<Tox_Options>)>();

  void tox_options_set_proxy_host(
    ffi.Pointer<Tox_Options> options,
    ffi.Pointer<ffi.Int8> host,
  ) {
    return _tox_options_set_proxy_host(
      options,
      host,
    );
  }

  late final _tox_options_set_proxy_hostPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<Tox_Options>,
              ffi.Pointer<ffi.Int8>)>>('tox_options_set_proxy_host');
  late final _tox_options_set_proxy_host =
      _tox_options_set_proxy_hostPtr.asFunction<
          void Function(ffi.Pointer<Tox_Options>, ffi.Pointer<ffi.Int8>)>();

  int tox_options_get_proxy_port(
    ffi.Pointer<Tox_Options> options,
  ) {
    return _tox_options_get_proxy_port(
      options,
    );
  }

  late final _tox_options_get_proxy_portPtr = _lookup<
          ffi.NativeFunction<ffi.Uint16 Function(ffi.Pointer<Tox_Options>)>>(
      'tox_options_get_proxy_port');
  late final _tox_options_get_proxy_port = _tox_options_get_proxy_portPtr
      .asFunction<int Function(ffi.Pointer<Tox_Options>)>();

  void tox_options_set_proxy_port(
    ffi.Pointer<Tox_Options> options,
    int port,
  ) {
    return _tox_options_set_proxy_port(
      options,
      port,
    );
  }

  late final _tox_options_set_proxy_portPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<Tox_Options>,
              ffi.Uint16)>>('tox_options_set_proxy_port');
  late final _tox_options_set_proxy_port = _tox_options_set_proxy_portPtr
      .asFunction<void Function(ffi.Pointer<Tox_Options>, int)>();

  int tox_options_get_start_port(
    ffi.Pointer<Tox_Options> options,
  ) {
    return _tox_options_get_start_port(
      options,
    );
  }

  late final _tox_options_get_start_portPtr = _lookup<
          ffi.NativeFunction<ffi.Uint16 Function(ffi.Pointer<Tox_Options>)>>(
      'tox_options_get_start_port');
  late final _tox_options_get_start_port = _tox_options_get_start_portPtr
      .asFunction<int Function(ffi.Pointer<Tox_Options>)>();

  void tox_options_set_start_port(
    ffi.Pointer<Tox_Options> options,
    int start_port,
  ) {
    return _tox_options_set_start_port(
      options,
      start_port,
    );
  }

  late final _tox_options_set_start_portPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<Tox_Options>,
              ffi.Uint16)>>('tox_options_set_start_port');
  late final _tox_options_set_start_port = _tox_options_set_start_portPtr
      .asFunction<void Function(ffi.Pointer<Tox_Options>, int)>();

  int tox_options_get_end_port(
    ffi.Pointer<Tox_Options> options,
  ) {
    return _tox_options_get_end_port(
      options,
    );
  }

  late final _tox_options_get_end_portPtr = _lookup<
          ffi.NativeFunction<ffi.Uint16 Function(ffi.Pointer<Tox_Options>)>>(
      'tox_options_get_end_port');
  late final _tox_options_get_end_port = _tox_options_get_end_portPtr
      .asFunction<int Function(ffi.Pointer<Tox_Options>)>();

  void tox_options_set_end_port(
    ffi.Pointer<Tox_Options> options,
    int end_port,
  ) {
    return _tox_options_set_end_port(
      options,
      end_port,
    );
  }

  late final _tox_options_set_end_portPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<Tox_Options>,
              ffi.Uint16)>>('tox_options_set_end_port');
  late final _tox_options_set_end_port = _tox_options_set_end_portPtr
      .asFunction<void Function(ffi.Pointer<Tox_Options>, int)>();

  int tox_options_get_tcp_port(
    ffi.Pointer<Tox_Options> options,
  ) {
    return _tox_options_get_tcp_port(
      options,
    );
  }

  late final _tox_options_get_tcp_portPtr = _lookup<
          ffi.NativeFunction<ffi.Uint16 Function(ffi.Pointer<Tox_Options>)>>(
      'tox_options_get_tcp_port');
  late final _tox_options_get_tcp_port = _tox_options_get_tcp_portPtr
      .asFunction<int Function(ffi.Pointer<Tox_Options>)>();

  void tox_options_set_tcp_port(
    ffi.Pointer<Tox_Options> options,
    int tcp_port,
  ) {
    return _tox_options_set_tcp_port(
      options,
      tcp_port,
    );
  }

  late final _tox_options_set_tcp_portPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<Tox_Options>,
              ffi.Uint16)>>('tox_options_set_tcp_port');
  late final _tox_options_set_tcp_port = _tox_options_set_tcp_portPtr
      .asFunction<void Function(ffi.Pointer<Tox_Options>, int)>();

  bool tox_options_get_hole_punching_enabled(
    ffi.Pointer<Tox_Options> options,
  ) {
    return _tox_options_get_hole_punching_enabled(
          options,
        ) !=
        0;
  }

  late final _tox_options_get_hole_punching_enabledPtr =
      _lookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<Tox_Options>)>>(
          'tox_options_get_hole_punching_enabled');
  late final _tox_options_get_hole_punching_enabled =
      _tox_options_get_hole_punching_enabledPtr
          .asFunction<int Function(ffi.Pointer<Tox_Options>)>();

  void tox_options_set_hole_punching_enabled(
    ffi.Pointer<Tox_Options> options,
    bool hole_punching_enabled,
  ) {
    return _tox_options_set_hole_punching_enabled(
      options,
      hole_punching_enabled ? 1 : 0,
    );
  }

  late final _tox_options_set_hole_punching_enabledPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<Tox_Options>,
              ffi.Uint8)>>('tox_options_set_hole_punching_enabled');
  late final _tox_options_set_hole_punching_enabled =
      _tox_options_set_hole_punching_enabledPtr
          .asFunction<void Function(ffi.Pointer<Tox_Options>, int)>();

  int tox_options_get_savedata_type(
    ffi.Pointer<Tox_Options> options,
  ) {
    return _tox_options_get_savedata_type(
      options,
    );
  }

  late final _tox_options_get_savedata_typePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<Tox_Options>)>>(
          'tox_options_get_savedata_type');
  late final _tox_options_get_savedata_type = _tox_options_get_savedata_typePtr
      .asFunction<int Function(ffi.Pointer<Tox_Options>)>();

  void tox_options_set_savedata_type(
    ffi.Pointer<Tox_Options> options,
    int type,
  ) {
    return _tox_options_set_savedata_type(
      options,
      type,
    );
  }

  late final _tox_options_set_savedata_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<Tox_Options>,
              ffi.Int32)>>('tox_options_set_savedata_type');
  late final _tox_options_set_savedata_type = _tox_options_set_savedata_typePtr
      .asFunction<void Function(ffi.Pointer<Tox_Options>, int)>();

  ffi.Pointer<ffi.Uint8> tox_options_get_savedata_data(
    ffi.Pointer<Tox_Options> options,
  ) {
    return _tox_options_get_savedata_data(
      options,
    );
  }

  late final _tox_options_get_savedata_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Uint8> Function(
              ffi.Pointer<Tox_Options>)>>('tox_options_get_savedata_data');
  late final _tox_options_get_savedata_data = _tox_options_get_savedata_dataPtr
      .asFunction<ffi.Pointer<ffi.Uint8> Function(ffi.Pointer<Tox_Options>)>();

  void tox_options_set_savedata_data(
    ffi.Pointer<Tox_Options> options,
    ffi.Pointer<ffi.Uint8> data,
    int length,
  ) {
    return _tox_options_set_savedata_data(
      options,
      data,
      length,
    );
  }

  late final _tox_options_set_savedata_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<Tox_Options>, ffi.Pointer<ffi.Uint8>,
              size_t)>>('tox_options_set_savedata_data');
  late final _tox_options_set_savedata_data =
      _tox_options_set_savedata_dataPtr.asFunction<
          void Function(
              ffi.Pointer<Tox_Options>, ffi.Pointer<ffi.Uint8>, int)>();

  int tox_options_get_savedata_length(
    ffi.Pointer<Tox_Options> options,
  ) {
    return _tox_options_get_savedata_length(
      options,
    );
  }

  late final _tox_options_get_savedata_lengthPtr =
      _lookup<ffi.NativeFunction<size_t Function(ffi.Pointer<Tox_Options>)>>(
          'tox_options_get_savedata_length');
  late final _tox_options_get_savedata_length =
      _tox_options_get_savedata_lengthPtr
          .asFunction<int Function(ffi.Pointer<Tox_Options>)>();

  void tox_options_set_savedata_length(
    ffi.Pointer<Tox_Options> options,
    int length,
  ) {
    return _tox_options_set_savedata_length(
      options,
      length,
    );
  }

  late final _tox_options_set_savedata_lengthPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<Tox_Options>,
              size_t)>>('tox_options_set_savedata_length');
  late final _tox_options_set_savedata_length =
      _tox_options_set_savedata_lengthPtr
          .asFunction<void Function(ffi.Pointer<Tox_Options>, int)>();

  ffi.Pointer<tox_log_cb> tox_options_get_log_callback(
    ffi.Pointer<Tox_Options> options,
  ) {
    return _tox_options_get_log_callback(
      options,
    );
  }

  late final _tox_options_get_log_callbackPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<tox_log_cb> Function(
              ffi.Pointer<Tox_Options>)>>('tox_options_get_log_callback');
  late final _tox_options_get_log_callback = _tox_options_get_log_callbackPtr
      .asFunction<ffi.Pointer<tox_log_cb> Function(ffi.Pointer<Tox_Options>)>();

  void tox_options_set_log_callback(
    ffi.Pointer<Tox_Options> options,
    ffi.Pointer<tox_log_cb> callback,
  ) {
    return _tox_options_set_log_callback(
      options,
      callback,
    );
  }

  late final _tox_options_set_log_callbackPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<Tox_Options>,
              ffi.Pointer<tox_log_cb>)>>('tox_options_set_log_callback');
  late final _tox_options_set_log_callback =
      _tox_options_set_log_callbackPtr.asFunction<
          void Function(ffi.Pointer<Tox_Options>, ffi.Pointer<tox_log_cb>)>();

  ffi.Pointer<ffi.Void> tox_options_get_log_user_data(
    ffi.Pointer<Tox_Options> options,
  ) {
    return _tox_options_get_log_user_data(
      options,
    );
  }

  late final _tox_options_get_log_user_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<Tox_Options>)>>('tox_options_get_log_user_data');
  late final _tox_options_get_log_user_data = _tox_options_get_log_user_dataPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<Tox_Options>)>();

  void tox_options_set_log_user_data(
    ffi.Pointer<Tox_Options> options,
    ffi.Pointer<ffi.Void> user_data,
  ) {
    return _tox_options_set_log_user_data(
      options,
      user_data,
    );
  }

  late final _tox_options_set_log_user_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<Tox_Options>,
              ffi.Pointer<ffi.Void>)>>('tox_options_set_log_user_data');
  late final _tox_options_set_log_user_data =
      _tox_options_set_log_user_dataPtr.asFunction<
          void Function(ffi.Pointer<Tox_Options>, ffi.Pointer<ffi.Void>)>();

  bool tox_options_get_experimental_thread_safety(
    ffi.Pointer<Tox_Options> options,
  ) {
    return _tox_options_get_experimental_thread_safety(
          options,
        ) !=
        0;
  }

  late final _tox_options_get_experimental_thread_safetyPtr =
      _lookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<Tox_Options>)>>(
          'tox_options_get_experimental_thread_safety');
  late final _tox_options_get_experimental_thread_safety =
      _tox_options_get_experimental_thread_safetyPtr
          .asFunction<int Function(ffi.Pointer<Tox_Options>)>();

  void tox_options_set_experimental_thread_safety(
    ffi.Pointer<Tox_Options> options,
    bool thread_safety,
  ) {
    return _tox_options_set_experimental_thread_safety(
      options,
      thread_safety ? 1 : 0,
    );
  }

  late final _tox_options_set_experimental_thread_safetyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<Tox_Options>,
              ffi.Uint8)>>('tox_options_set_experimental_thread_safety');
  late final _tox_options_set_experimental_thread_safety =
      _tox_options_set_experimental_thread_safetyPtr
          .asFunction<void Function(ffi.Pointer<Tox_Options>, int)>();

  /// Initialises a Tox_Options object with the default options.
  ///
  /// The result of this function is independent of the original options. All
  /// values will be overwritten, no values will be read (so it is permissible
  /// to pass an uninitialised object).
  ///
  /// If options is NULL, this function has no effect.
  ///
  /// @param options An options object to be filled with default options.
  void tox_options_default(
    ffi.Pointer<Tox_Options> options,
  ) {
    return _tox_options_default(
      options,
    );
  }

  late final _tox_options_defaultPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<Tox_Options>)>>(
          'tox_options_default');
  late final _tox_options_default = _tox_options_defaultPtr
      .asFunction<void Function(ffi.Pointer<Tox_Options>)>();

  /// Allocates a new Tox_Options object and initialises it with the default
  /// options. This function can be used to preserve long term ABI compatibility by
  /// giving the responsibility of allocation and deallocation to the Tox library.
  ///
  /// Objects returned from this function must be freed using the tox_options_free
  /// function.
  ///
  /// @return A new Tox_Options object with default options or NULL on failure.
  ffi.Pointer<Tox_Options> tox_options_new(
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_options_new(
      error,
    );
  }

  late final _tox_options_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<Tox_Options> Function(
              ffi.Pointer<ffi.Int32>)>>('tox_options_new');
  late final _tox_options_new = _tox_options_newPtr
      .asFunction<ffi.Pointer<Tox_Options> Function(ffi.Pointer<ffi.Int32>)>();

  /// Releases all resources associated with an options objects.
  ///
  /// Passing a pointer that was not returned by tox_options_new results in
  /// undefined behaviour.
  void tox_options_free(
    ffi.Pointer<Tox_Options> options,
  ) {
    return _tox_options_free(
      options,
    );
  }

  late final _tox_options_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<Tox_Options>)>>(
          'tox_options_free');
  late final _tox_options_free = _tox_options_freePtr
      .asFunction<void Function(ffi.Pointer<Tox_Options>)>();

  /// @brief Creates and initialises a new Tox instance with the options passed.
  ///
  /// This function will bring the instance into a valid state. Running the event
  /// loop with a new instance will operate correctly.
  ///
  /// If loading failed or succeeded only partially, the new or partially loaded
  /// instance is returned and an error code is set.
  ///
  /// @param options An options object as described above. If this parameter is
  /// NULL, the default options are used.
  ///
  /// @see tox_iterate for the event loop.
  ///
  /// @return A new Tox instance pointer on success or NULL on failure.
  ffi.Pointer<Tox> tox_new(
    ffi.Pointer<Tox_Options> options,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_new(
      options,
      error,
    );
  }

  late final _tox_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<Tox> Function(
              ffi.Pointer<Tox_Options>, ffi.Pointer<ffi.Int32>)>>('tox_new');
  late final _tox_new = _tox_newPtr.asFunction<
      ffi.Pointer<Tox> Function(
          ffi.Pointer<Tox_Options>, ffi.Pointer<ffi.Int32>)>();

  /// Releases all resources associated with the Tox instance and disconnects from
  /// the network.
  ///
  /// After calling this function, the Tox pointer becomes invalid. No other
  /// functions can be called, and the pointer value can no longer be read.
  void tox_kill(
    ffi.Pointer<Tox> tox,
  ) {
    return _tox_kill(
      tox,
    );
  }

  late final _tox_killPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<Tox>)>>(
          'tox_kill');
  late final _tox_kill =
      _tox_killPtr.asFunction<void Function(ffi.Pointer<Tox>)>();

  /// Calculates the number of bytes required to store the tox instance with
  /// tox_get_savedata. This function cannot fail. The result is always greater than 0.
  ///
  /// @see threading for concurrency implications.
  int tox_get_savedata_size(
    ffi.Pointer<Tox> tox,
  ) {
    return _tox_get_savedata_size(
      tox,
    );
  }

  late final _tox_get_savedata_sizePtr =
      _lookup<ffi.NativeFunction<size_t Function(ffi.Pointer<Tox>)>>(
          'tox_get_savedata_size');
  late final _tox_get_savedata_size =
      _tox_get_savedata_sizePtr.asFunction<int Function(ffi.Pointer<Tox>)>();

  /// Store all information associated with the tox instance to a byte array.
  ///
  /// @param savedata A memory region large enough to store the tox instance
  /// data. Call tox_get_savedata_size to find the number of bytes required. If this parameter
  /// is NULL, this function has no effect.
  void tox_get_savedata(
    ffi.Pointer<Tox> tox,
    ffi.Pointer<ffi.Uint8> savedata,
  ) {
    return _tox_get_savedata(
      tox,
      savedata,
    );
  }

  late final _tox_get_savedataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<Tox>, ffi.Pointer<ffi.Uint8>)>>('tox_get_savedata');
  late final _tox_get_savedata = _tox_get_savedataPtr
      .asFunction<void Function(ffi.Pointer<Tox>, ffi.Pointer<ffi.Uint8>)>();

  /// Sends a "get nodes" request to the given bootstrap node with IP, port, and
  /// public key to setup connections.
  ///
  /// This function will attempt to connect to the node using UDP. You must use
  /// this function even if Tox_Options.udp_enabled was set to false.
  ///
  /// @param host The hostname or IP address (IPv4 or IPv6) of the node. Must be
  /// at most TOX_MAX_HOSTNAME_LENGTH chars, including the NUL byte.
  /// @param port The port on the host on which the bootstrap Tox instance is
  /// listening.
  /// @param public_key The long term public key of the bootstrap node
  /// (TOX_PUBLIC_KEY_SIZE bytes).
  /// @return true on success.
  bool tox_bootstrap(
    ffi.Pointer<Tox> tox,
    ffi.Pointer<ffi.Int8> host,
    int port,
    ffi.Pointer<ffi.Uint8> public_key,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_bootstrap(
          tox,
          host,
          port,
          public_key,
          error,
        ) !=
        0;
  }

  late final _tox_bootstrapPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint8 Function(
              ffi.Pointer<Tox>,
              ffi.Pointer<ffi.Int8>,
              ffi.Uint16,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Int32>)>>('tox_bootstrap');
  late final _tox_bootstrap = _tox_bootstrapPtr.asFunction<
      int Function(ffi.Pointer<Tox>, ffi.Pointer<ffi.Int8>, int,
          ffi.Pointer<ffi.Uint8>, ffi.Pointer<ffi.Int32>)>();

  /// Adds additional host:port pair as TCP relay.
  ///
  /// This function can be used to initiate TCP connections to different ports on
  /// the same bootstrap node, or to add TCP relays without using them as
  /// bootstrap nodes.
  ///
  /// @param host The hostname or IP address (IPv4 or IPv6) of the TCP relay.
  /// Must be at most TOX_MAX_HOSTNAME_LENGTH chars, including the NUL byte.
  /// @param port The port on the host on which the TCP relay is listening.
  /// @param public_key The long term public key of the TCP relay
  /// (TOX_PUBLIC_KEY_SIZE bytes).
  /// @return true on success.
  bool tox_add_tcp_relay(
    ffi.Pointer<Tox> tox,
    ffi.Pointer<ffi.Int8> host,
    int port,
    ffi.Pointer<ffi.Uint8> public_key,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_add_tcp_relay(
          tox,
          host,
          port,
          public_key,
          error,
        ) !=
        0;
  }

  late final _tox_add_tcp_relayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint8 Function(
              ffi.Pointer<Tox>,
              ffi.Pointer<ffi.Int8>,
              ffi.Uint16,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Int32>)>>('tox_add_tcp_relay');
  late final _tox_add_tcp_relay = _tox_add_tcp_relayPtr.asFunction<
      int Function(ffi.Pointer<Tox>, ffi.Pointer<ffi.Int8>, int,
          ffi.Pointer<ffi.Uint8>, ffi.Pointer<ffi.Int32>)>();

  /// Return whether we are connected to the DHT. The return value is equal to the
  /// last value received through the `self_connection_status` callback.
  ///
  /// @deprecated This getter is deprecated. Use the event and store the status
  /// in the client state.
  int tox_self_get_connection_status(
    ffi.Pointer<Tox> tox,
  ) {
    return _tox_self_get_connection_status(
      tox,
    );
  }

  late final _tox_self_get_connection_statusPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<Tox>)>>(
          'tox_self_get_connection_status');
  late final _tox_self_get_connection_status =
      _tox_self_get_connection_statusPtr
          .asFunction<int Function(ffi.Pointer<Tox>)>();

  /// Set the callback for the `self_connection_status` event. Pass NULL to unset.
  ///
  /// This event is triggered whenever there is a change in the DHT connection
  /// state. When disconnected, a client may choose to call tox_bootstrap again, to
  /// reconnect to the DHT. Note that this state may frequently change for short
  /// amounts of time. Clients should therefore not immediately bootstrap on
  /// receiving a disconnect.
  ///
  /// TODO(iphydf): how long should a client wait before bootstrapping again?
  void tox_callback_self_connection_status(
    ffi.Pointer<Tox> tox,
    ffi.Pointer<tox_self_connection_status_cb> callback,
  ) {
    return _tox_callback_self_connection_status(
      tox,
      callback,
    );
  }

  late final _tox_callback_self_connection_statusPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<Tox>,
                  ffi.Pointer<tox_self_connection_status_cb>)>>(
      'tox_callback_self_connection_status');
  late final _tox_callback_self_connection_status =
      _tox_callback_self_connection_statusPtr.asFunction<
          void Function(
              ffi.Pointer<Tox>, ffi.Pointer<tox_self_connection_status_cb>)>();

  /// Return the time in milliseconds before tox_iterate() should be called again
  /// for optimal performance.
  int tox_iteration_interval(
    ffi.Pointer<Tox> tox,
  ) {
    return _tox_iteration_interval(
      tox,
    );
  }

  late final _tox_iteration_intervalPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.Pointer<Tox>)>>(
          'tox_iteration_interval');
  late final _tox_iteration_interval =
      _tox_iteration_intervalPtr.asFunction<int Function(ffi.Pointer<Tox>)>();

  /// The main loop that needs to be run in intervals of tox_iteration_interval()
  /// milliseconds.
  void tox_iterate(
    ffi.Pointer<Tox> tox,
    ffi.Pointer<ffi.Void> user_data,
  ) {
    return _tox_iterate(
      tox,
      user_data,
    );
  }

  late final _tox_iteratePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<Tox>, ffi.Pointer<ffi.Void>)>>('tox_iterate');
  late final _tox_iterate = _tox_iteratePtr
      .asFunction<void Function(ffi.Pointer<Tox>, ffi.Pointer<ffi.Void>)>();

  /// Writes the Tox friend address of the client to a byte array. The address is
  /// not in human-readable format. If a client wants to display the address,
  /// formatting is required.
  ///
  /// @param address A memory region of at least TOX_ADDRESS_SIZE bytes. If this
  /// parameter is NULL, this function has no effect.
  /// @see TOX_ADDRESS_SIZE for the address format.
  void tox_self_get_address(
    ffi.Pointer<Tox> tox,
    ffi.Pointer<ffi.Uint8> address,
  ) {
    return _tox_self_get_address(
      tox,
      address,
    );
  }

  late final _tox_self_get_addressPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<Tox>,
              ffi.Pointer<ffi.Uint8>)>>('tox_self_get_address');
  late final _tox_self_get_address = _tox_self_get_addressPtr
      .asFunction<void Function(ffi.Pointer<Tox>, ffi.Pointer<ffi.Uint8>)>();

  /// Set the 4-byte nospam part of the address. This value is expected in host
  /// byte order. I.e. 0x12345678 will form the bytes `[12, 34, 56, 78]` in the
  /// nospam part of the Tox friend address.
  ///
  /// @param nospam Any 32 bit unsigned integer.
  void tox_self_set_nospam(
    ffi.Pointer<Tox> tox,
    int nospam,
  ) {
    return _tox_self_set_nospam(
      tox,
      nospam,
    );
  }

  late final _tox_self_set_nospamPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<Tox>, ffi.Uint32)>>(
      'tox_self_set_nospam');
  late final _tox_self_set_nospam = _tox_self_set_nospamPtr
      .asFunction<void Function(ffi.Pointer<Tox>, int)>();

  /// Get the 4-byte nospam part of the address. This value is returned in host
  /// byte order.
  int tox_self_get_nospam(
    ffi.Pointer<Tox> tox,
  ) {
    return _tox_self_get_nospam(
      tox,
    );
  }

  late final _tox_self_get_nospamPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.Pointer<Tox>)>>(
          'tox_self_get_nospam');
  late final _tox_self_get_nospam =
      _tox_self_get_nospamPtr.asFunction<int Function(ffi.Pointer<Tox>)>();

  /// Copy the Tox Public Key (long term) from the Tox object.
  ///
  /// @param public_key A memory region of at least TOX_PUBLIC_KEY_SIZE bytes. If
  /// this parameter is NULL, this function has no effect.
  void tox_self_get_public_key(
    ffi.Pointer<Tox> tox,
    ffi.Pointer<ffi.Uint8> public_key,
  ) {
    return _tox_self_get_public_key(
      tox,
      public_key,
    );
  }

  late final _tox_self_get_public_keyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<Tox>,
              ffi.Pointer<ffi.Uint8>)>>('tox_self_get_public_key');
  late final _tox_self_get_public_key = _tox_self_get_public_keyPtr
      .asFunction<void Function(ffi.Pointer<Tox>, ffi.Pointer<ffi.Uint8>)>();

  /// Copy the Tox Secret Key from the Tox object.
  ///
  /// @param secret_key A memory region of at least TOX_SECRET_KEY_SIZE bytes. If
  /// this parameter is NULL, this function has no effect.
  void tox_self_get_secret_key(
    ffi.Pointer<Tox> tox,
    ffi.Pointer<ffi.Uint8> secret_key,
  ) {
    return _tox_self_get_secret_key(
      tox,
      secret_key,
    );
  }

  late final _tox_self_get_secret_keyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<Tox>,
              ffi.Pointer<ffi.Uint8>)>>('tox_self_get_secret_key');
  late final _tox_self_get_secret_key = _tox_self_get_secret_keyPtr
      .asFunction<void Function(ffi.Pointer<Tox>, ffi.Pointer<ffi.Uint8>)>();

  /// Set the nickname for the Tox client.
  ///
  /// Nickname length cannot exceed TOX_MAX_NAME_LENGTH. If length is 0, the name
  /// parameter is ignored (it can be NULL), and the nickname is set back to empty.
  ///
  /// @param name A byte array containing the new nickname.
  /// @param length The size of the name byte array.
  ///
  /// @return true on success.
  bool tox_self_set_name(
    ffi.Pointer<Tox> tox,
    ffi.Pointer<ffi.Uint8> name,
    int length,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_self_set_name(
          tox,
          name,
          length,
          error,
        ) !=
        0;
  }

  late final _tox_self_set_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint8 Function(ffi.Pointer<Tox>, ffi.Pointer<ffi.Uint8>, size_t,
              ffi.Pointer<ffi.Int32>)>>('tox_self_set_name');
  late final _tox_self_set_name = _tox_self_set_namePtr.asFunction<
      int Function(ffi.Pointer<Tox>, ffi.Pointer<ffi.Uint8>, int,
          ffi.Pointer<ffi.Int32>)>();

  /// Return the length of the current nickname as passed to tox_self_set_name.
  ///
  /// If no nickname was set before calling this function, the name is empty,
  /// and this function returns 0.
  ///
  /// @see threading for concurrency implications.
  int tox_self_get_name_size(
    ffi.Pointer<Tox> tox,
  ) {
    return _tox_self_get_name_size(
      tox,
    );
  }

  late final _tox_self_get_name_sizePtr =
      _lookup<ffi.NativeFunction<size_t Function(ffi.Pointer<Tox>)>>(
          'tox_self_get_name_size');
  late final _tox_self_get_name_size =
      _tox_self_get_name_sizePtr.asFunction<int Function(ffi.Pointer<Tox>)>();

  /// Write the nickname set by tox_self_set_name to a byte array.
  ///
  /// If no nickname was set before calling this function, the name is empty,
  /// and this function has no effect.
  ///
  /// Call tox_self_get_name_size to find out how much memory to allocate for
  /// the result.
  ///
  /// @param name A valid memory location large enough to hold the nickname.
  /// If this parameter is NULL, the function has no effect.
  void tox_self_get_name(
    ffi.Pointer<Tox> tox,
    ffi.Pointer<ffi.Uint8> name,
  ) {
    return _tox_self_get_name(
      tox,
      name,
    );
  }

  late final _tox_self_get_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<Tox>, ffi.Pointer<ffi.Uint8>)>>('tox_self_get_name');
  late final _tox_self_get_name = _tox_self_get_namePtr
      .asFunction<void Function(ffi.Pointer<Tox>, ffi.Pointer<ffi.Uint8>)>();

  /// Set the client's status message.
  ///
  /// Status message length cannot exceed TOX_MAX_STATUS_MESSAGE_LENGTH. If
  /// length is 0, the status parameter is ignored (it can be NULL), and the
  /// user status is set back to empty.
  bool tox_self_set_status_message(
    ffi.Pointer<Tox> tox,
    ffi.Pointer<ffi.Uint8> status_message,
    int length,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_self_set_status_message(
          tox,
          status_message,
          length,
          error,
        ) !=
        0;
  }

  late final _tox_self_set_status_messagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint8 Function(ffi.Pointer<Tox>, ffi.Pointer<ffi.Uint8>, size_t,
              ffi.Pointer<ffi.Int32>)>>('tox_self_set_status_message');
  late final _tox_self_set_status_message =
      _tox_self_set_status_messagePtr.asFunction<
          int Function(ffi.Pointer<Tox>, ffi.Pointer<ffi.Uint8>, int,
              ffi.Pointer<ffi.Int32>)>();

  /// Return the length of the current status message as passed to tox_self_set_status_message.
  ///
  /// If no status message was set before calling this function, the status
  /// is empty, and this function returns 0.
  ///
  /// @see threading for concurrency implications.
  int tox_self_get_status_message_size(
    ffi.Pointer<Tox> tox,
  ) {
    return _tox_self_get_status_message_size(
      tox,
    );
  }

  late final _tox_self_get_status_message_sizePtr =
      _lookup<ffi.NativeFunction<size_t Function(ffi.Pointer<Tox>)>>(
          'tox_self_get_status_message_size');
  late final _tox_self_get_status_message_size =
      _tox_self_get_status_message_sizePtr
          .asFunction<int Function(ffi.Pointer<Tox>)>();

  /// Write the status message set by tox_self_set_status_message to a byte array.
  ///
  /// If no status message was set before calling this function, the status is
  /// empty, and this function has no effect.
  ///
  /// Call tox_self_get_status_message_size to find out how much memory to allocate for
  /// the result.
  ///
  /// @param status_message A valid memory location large enough to hold the
  /// status message. If this parameter is NULL, the function has no effect.
  void tox_self_get_status_message(
    ffi.Pointer<Tox> tox,
    ffi.Pointer<ffi.Uint8> status_message,
  ) {
    return _tox_self_get_status_message(
      tox,
      status_message,
    );
  }

  late final _tox_self_get_status_messagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<Tox>,
              ffi.Pointer<ffi.Uint8>)>>('tox_self_get_status_message');
  late final _tox_self_get_status_message = _tox_self_get_status_messagePtr
      .asFunction<void Function(ffi.Pointer<Tox>, ffi.Pointer<ffi.Uint8>)>();

  /// Set the client's user status.
  ///
  /// @param status One of the user statuses listed in the enumeration above.
  void tox_self_set_status(
    ffi.Pointer<Tox> tox,
    int status,
  ) {
    return _tox_self_set_status(
      tox,
      status,
    );
  }

  late final _tox_self_set_statusPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<Tox>, ffi.Int32)>>(
      'tox_self_set_status');
  late final _tox_self_set_status = _tox_self_set_statusPtr
      .asFunction<void Function(ffi.Pointer<Tox>, int)>();

  /// Returns the client's user status.
  int tox_self_get_status(
    ffi.Pointer<Tox> tox,
  ) {
    return _tox_self_get_status(
      tox,
    );
  }

  late final _tox_self_get_statusPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<Tox>)>>(
          'tox_self_get_status');
  late final _tox_self_get_status =
      _tox_self_get_statusPtr.asFunction<int Function(ffi.Pointer<Tox>)>();

  /// Add a friend to the friend list and send a friend request.
  ///
  /// A friend request message must be at least 1 byte long and at most
  /// TOX_MAX_FRIEND_REQUEST_LENGTH.
  ///
  /// Friend numbers are unique identifiers used in all functions that operate on
  /// friends. Once added, a friend number is stable for the lifetime of the Tox
  /// object. After saving the state and reloading it, the friend numbers may not
  /// be the same as before. Deleting a friend creates a gap in the friend number
  /// set, which is filled by the next adding of a friend. Any pattern in friend
  /// numbers should not be relied on.
  ///
  /// If more than INT32_MAX friends are added, this function causes undefined
  /// behaviour.
  ///
  /// @param address The address of the friend (returned by tox_self_get_address of
  /// the friend you wish to add) it must be TOX_ADDRESS_SIZE bytes.
  /// @param message The message that will be sent along with the friend request.
  /// @param length The length of the data byte array.
  ///
  /// @return the friend number on success, an unspecified value on failure.
  int tox_friend_add(
    ffi.Pointer<Tox> tox,
    ffi.Pointer<ffi.Uint8> address,
    ffi.Pointer<ffi.Uint8> message,
    int length,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_friend_add(
      tox,
      address,
      message,
      length,
      error,
    );
  }

  late final _tox_friend_addPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Pointer<Tox>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Uint8>,
              size_t,
              ffi.Pointer<ffi.Int32>)>>('tox_friend_add');
  late final _tox_friend_add = _tox_friend_addPtr.asFunction<
      int Function(ffi.Pointer<Tox>, ffi.Pointer<ffi.Uint8>,
          ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Int32>)>();

  /// Add a friend without sending a friend request.
  ///
  /// This function is used to add a friend in response to a friend request. If the
  /// client receives a friend request, it can be reasonably sure that the other
  /// client added this client as a friend, eliminating the need for a friend
  /// request.
  ///
  /// This function is also useful in a situation where both instances are
  /// controlled by the same entity, so that this entity can perform the mutual
  /// friend adding. In this case, there is no need for a friend request, either.
  ///
  /// @param public_key A byte array of length TOX_PUBLIC_KEY_SIZE containing the
  /// Public Key (not the Address) of the friend to add.
  ///
  /// @return the friend number on success, an unspecified value on failure.
  /// @see tox_friend_add for a more detailed description of friend numbers.
  int tox_friend_add_norequest(
    ffi.Pointer<Tox> tox,
    ffi.Pointer<ffi.Uint8> public_key,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_friend_add_norequest(
      tox,
      public_key,
      error,
    );
  }

  late final _tox_friend_add_norequestPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(ffi.Pointer<Tox>, ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Int32>)>>('tox_friend_add_norequest');
  late final _tox_friend_add_norequest =
      _tox_friend_add_norequestPtr.asFunction<
          int Function(ffi.Pointer<Tox>, ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Int32>)>();

  /// Remove a friend from the friend list.
  ///
  /// This does not notify the friend of their deletion. After calling this
  /// function, this client will appear offline to the friend and no communication
  /// can occur between the two.
  ///
  /// @param friend_number Friend number for the friend to be deleted.
  ///
  /// @return true on success.
  bool tox_friend_delete(
    ffi.Pointer<Tox> tox,
    int friend_number,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_friend_delete(
          tox,
          friend_number,
          error,
        ) !=
        0;
  }

  late final _tox_friend_deletePtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint8 Function(ffi.Pointer<Tox>, ffi.Uint32,
              ffi.Pointer<ffi.Int32>)>>('tox_friend_delete');
  late final _tox_friend_delete = _tox_friend_deletePtr.asFunction<
      int Function(ffi.Pointer<Tox>, int, ffi.Pointer<ffi.Int32>)>();

  /// Return the friend number associated with that Public Key.
  ///
  /// @return the friend number on success, an unspecified value on failure.
  /// @param public_key A byte array containing the Public Key.
  int tox_friend_by_public_key(
    ffi.Pointer<Tox> tox,
    ffi.Pointer<ffi.Uint8> public_key,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_friend_by_public_key(
      tox,
      public_key,
      error,
    );
  }

  late final _tox_friend_by_public_keyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(ffi.Pointer<Tox>, ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Int32>)>>('tox_friend_by_public_key');
  late final _tox_friend_by_public_key =
      _tox_friend_by_public_keyPtr.asFunction<
          int Function(ffi.Pointer<Tox>, ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Int32>)>();

  /// Checks if a friend with the given friend number exists and returns true if
  /// it does.
  bool tox_friend_exists(
    ffi.Pointer<Tox> tox,
    int friend_number,
  ) {
    return _tox_friend_exists(
          tox,
          friend_number,
        ) !=
        0;
  }

  late final _tox_friend_existsPtr = _lookup<
          ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<Tox>, ffi.Uint32)>>(
      'tox_friend_exists');
  late final _tox_friend_exists =
      _tox_friend_existsPtr.asFunction<int Function(ffi.Pointer<Tox>, int)>();

  /// Return the number of friends on the friend list.
  ///
  /// This function can be used to determine how much memory to allocate for
  /// tox_self_get_friend_list.
  int tox_self_get_friend_list_size(
    ffi.Pointer<Tox> tox,
  ) {
    return _tox_self_get_friend_list_size(
      tox,
    );
  }

  late final _tox_self_get_friend_list_sizePtr =
      _lookup<ffi.NativeFunction<size_t Function(ffi.Pointer<Tox>)>>(
          'tox_self_get_friend_list_size');
  late final _tox_self_get_friend_list_size = _tox_self_get_friend_list_sizePtr
      .asFunction<int Function(ffi.Pointer<Tox>)>();

  /// Copy a list of valid friend numbers into an array.
  ///
  /// Call tox_self_get_friend_list_size to determine the number of elements to allocate.
  ///
  /// @param friend_list A memory region with enough space to hold the friend
  /// list. If this parameter is NULL, this function has no effect.
  void tox_self_get_friend_list(
    ffi.Pointer<Tox> tox,
    ffi.Pointer<ffi.Uint32> friend_list,
  ) {
    return _tox_self_get_friend_list(
      tox,
      friend_list,
    );
  }

  late final _tox_self_get_friend_listPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<Tox>,
              ffi.Pointer<ffi.Uint32>)>>('tox_self_get_friend_list');
  late final _tox_self_get_friend_list = _tox_self_get_friend_listPtr
      .asFunction<void Function(ffi.Pointer<Tox>, ffi.Pointer<ffi.Uint32>)>();

  /// Copies the Public Key associated with a given friend number to a byte array.
  ///
  /// @param friend_number The friend number you want the Public Key of.
  /// @param public_key A memory region of at least TOX_PUBLIC_KEY_SIZE bytes. If
  /// this parameter is NULL, this function has no effect.
  ///
  /// @return true on success.
  bool tox_friend_get_public_key(
    ffi.Pointer<Tox> tox,
    int friend_number,
    ffi.Pointer<ffi.Uint8> public_key,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_friend_get_public_key(
          tox,
          friend_number,
          public_key,
          error,
        ) !=
        0;
  }

  late final _tox_friend_get_public_keyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint8 Function(
              ffi.Pointer<Tox>,
              ffi.Uint32,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Int32>)>>('tox_friend_get_public_key');
  late final _tox_friend_get_public_key =
      _tox_friend_get_public_keyPtr.asFunction<
          int Function(ffi.Pointer<Tox>, int, ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Int32>)>();

  /// Return a unix-time timestamp of the last time the friend associated with a given
  /// friend number was seen online. This function will return UINT64_MAX on error.
  ///
  /// @param friend_number The friend number you want to query.
  int tox_friend_get_last_online(
    ffi.Pointer<Tox> tox,
    int friend_number,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_friend_get_last_online(
      tox,
      friend_number,
      error,
    );
  }

  late final _tox_friend_get_last_onlinePtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint64 Function(ffi.Pointer<Tox>, ffi.Uint32,
              ffi.Pointer<ffi.Int32>)>>('tox_friend_get_last_online');
  late final _tox_friend_get_last_online =
      _tox_friend_get_last_onlinePtr.asFunction<
          int Function(ffi.Pointer<Tox>, int, ffi.Pointer<ffi.Int32>)>();

  /// Return the length of the friend's name. If the friend number is invalid, the
  /// return value is unspecified.
  ///
  /// The return value is equal to the `length` argument received by the last
  /// `friend_name` callback.
  int tox_friend_get_name_size(
    ffi.Pointer<Tox> tox,
    int friend_number,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_friend_get_name_size(
      tox,
      friend_number,
      error,
    );
  }

  late final _tox_friend_get_name_sizePtr = _lookup<
      ffi.NativeFunction<
          size_t Function(ffi.Pointer<Tox>, ffi.Uint32,
              ffi.Pointer<ffi.Int32>)>>('tox_friend_get_name_size');
  late final _tox_friend_get_name_size =
      _tox_friend_get_name_sizePtr.asFunction<
          int Function(ffi.Pointer<Tox>, int, ffi.Pointer<ffi.Int32>)>();

  /// Write the name of the friend designated by the given friend number to a byte
  /// array.
  ///
  /// Call tox_friend_get_name_size to determine the allocation size for the `name`
  /// parameter.
  ///
  /// The data written to `name` is equal to the data received by the last
  /// `friend_name` callback.
  ///
  /// @param name A valid memory region large enough to store the friend's name.
  ///
  /// @return true on success.
  bool tox_friend_get_name(
    ffi.Pointer<Tox> tox,
    int friend_number,
    ffi.Pointer<ffi.Uint8> name,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_friend_get_name(
          tox,
          friend_number,
          name,
          error,
        ) !=
        0;
  }

  late final _tox_friend_get_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint8 Function(
              ffi.Pointer<Tox>,
              ffi.Uint32,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Int32>)>>('tox_friend_get_name');
  late final _tox_friend_get_name = _tox_friend_get_namePtr.asFunction<
      int Function(ffi.Pointer<Tox>, int, ffi.Pointer<ffi.Uint8>,
          ffi.Pointer<ffi.Int32>)>();

  /// Set the callback for the `friend_name` event. Pass NULL to unset.
  ///
  /// This event is triggered when a friend changes their name.
  void tox_callback_friend_name(
    ffi.Pointer<Tox> tox,
    ffi.Pointer<tox_friend_name_cb> callback,
  ) {
    return _tox_callback_friend_name(
      tox,
      callback,
    );
  }

  late final _tox_callback_friend_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<Tox>,
              ffi.Pointer<tox_friend_name_cb>)>>('tox_callback_friend_name');
  late final _tox_callback_friend_name =
      _tox_callback_friend_namePtr.asFunction<
          void Function(ffi.Pointer<Tox>, ffi.Pointer<tox_friend_name_cb>)>();

  /// Return the length of the friend's status message. If the friend number is
  /// invalid, the return value is SIZE_MAX.
  int tox_friend_get_status_message_size(
    ffi.Pointer<Tox> tox,
    int friend_number,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_friend_get_status_message_size(
      tox,
      friend_number,
      error,
    );
  }

  late final _tox_friend_get_status_message_sizePtr = _lookup<
      ffi.NativeFunction<
          size_t Function(ffi.Pointer<Tox>, ffi.Uint32,
              ffi.Pointer<ffi.Int32>)>>('tox_friend_get_status_message_size');
  late final _tox_friend_get_status_message_size =
      _tox_friend_get_status_message_sizePtr.asFunction<
          int Function(ffi.Pointer<Tox>, int, ffi.Pointer<ffi.Int32>)>();

  /// Write the status message of the friend designated by the given friend number to a byte
  /// array.
  ///
  /// Call tox_friend_get_status_message_size to determine the allocation size for the `status_message`
  /// parameter.
  ///
  /// The data written to `status_message` is equal to the data received by the last
  /// `friend_status_message` callback.
  ///
  /// @param status_message A valid memory region large enough to store the friend's status message.
  bool tox_friend_get_status_message(
    ffi.Pointer<Tox> tox,
    int friend_number,
    ffi.Pointer<ffi.Uint8> status_message,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_friend_get_status_message(
          tox,
          friend_number,
          status_message,
          error,
        ) !=
        0;
  }

  late final _tox_friend_get_status_messagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint8 Function(
              ffi.Pointer<Tox>,
              ffi.Uint32,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Int32>)>>('tox_friend_get_status_message');
  late final _tox_friend_get_status_message =
      _tox_friend_get_status_messagePtr.asFunction<
          int Function(ffi.Pointer<Tox>, int, ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Int32>)>();

  /// Set the callback for the `friend_status_message` event. Pass NULL to unset.
  ///
  /// This event is triggered when a friend changes their status message.
  void tox_callback_friend_status_message(
    ffi.Pointer<Tox> tox,
    ffi.Pointer<tox_friend_status_message_cb> callback,
  ) {
    return _tox_callback_friend_status_message(
      tox,
      callback,
    );
  }

  late final _tox_callback_friend_status_messagePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<Tox>,
                  ffi.Pointer<tox_friend_status_message_cb>)>>(
      'tox_callback_friend_status_message');
  late final _tox_callback_friend_status_message =
      _tox_callback_friend_status_messagePtr.asFunction<
          void Function(
              ffi.Pointer<Tox>, ffi.Pointer<tox_friend_status_message_cb>)>();

  /// Return the friend's user status (away/busy/...). If the friend number is
  /// invalid, the return value is unspecified.
  ///
  /// The status returned is equal to the last status received through the
  /// `friend_status` callback.
  ///
  /// @deprecated This getter is deprecated. Use the event and store the status
  /// in the client state.
  int tox_friend_get_status(
    ffi.Pointer<Tox> tox,
    int friend_number,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_friend_get_status(
      tox,
      friend_number,
      error,
    );
  }

  late final _tox_friend_get_statusPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<Tox>, ffi.Uint32,
              ffi.Pointer<ffi.Int32>)>>('tox_friend_get_status');
  late final _tox_friend_get_status = _tox_friend_get_statusPtr.asFunction<
      int Function(ffi.Pointer<Tox>, int, ffi.Pointer<ffi.Int32>)>();

  /// Set the callback for the `friend_status` event. Pass NULL to unset.
  ///
  /// This event is triggered when a friend changes their user status.
  void tox_callback_friend_status(
    ffi.Pointer<Tox> tox,
    ffi.Pointer<tox_friend_status_cb> callback,
  ) {
    return _tox_callback_friend_status(
      tox,
      callback,
    );
  }

  late final _tox_callback_friend_statusPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<Tox>, ffi.Pointer<tox_friend_status_cb>)>>(
      'tox_callback_friend_status');
  late final _tox_callback_friend_status =
      _tox_callback_friend_statusPtr.asFunction<
          void Function(ffi.Pointer<Tox>, ffi.Pointer<tox_friend_status_cb>)>();

  /// Check whether a friend is currently connected to this client.
  ///
  /// The result of this function is equal to the last value received by the
  /// `friend_connection_status` callback.
  ///
  /// @param friend_number The friend number for which to query the connection
  /// status.
  ///
  /// @return the friend's connection status as it was received through the
  /// `friend_connection_status` event.
  ///
  /// @deprecated This getter is deprecated. Use the event and store the status
  /// in the client state.
  int tox_friend_get_connection_status(
    ffi.Pointer<Tox> tox,
    int friend_number,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_friend_get_connection_status(
      tox,
      friend_number,
      error,
    );
  }

  late final _tox_friend_get_connection_statusPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<Tox>, ffi.Uint32,
              ffi.Pointer<ffi.Int32>)>>('tox_friend_get_connection_status');
  late final _tox_friend_get_connection_status =
      _tox_friend_get_connection_statusPtr.asFunction<
          int Function(ffi.Pointer<Tox>, int, ffi.Pointer<ffi.Int32>)>();

  /// Set the callback for the `friend_connection_status` event. Pass NULL to unset.
  ///
  /// This event is triggered when a friend goes offline after having been online,
  /// or when a friend goes online.
  ///
  /// This callback is not called when adding friends. It is assumed that when
  /// adding friends, their connection status is initially offline.
  void tox_callback_friend_connection_status(
    ffi.Pointer<Tox> tox,
    ffi.Pointer<tox_friend_connection_status_cb> callback,
  ) {
    return _tox_callback_friend_connection_status(
      tox,
      callback,
    );
  }

  late final _tox_callback_friend_connection_statusPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<Tox>,
                  ffi.Pointer<tox_friend_connection_status_cb>)>>(
      'tox_callback_friend_connection_status');
  late final _tox_callback_friend_connection_status =
      _tox_callback_friend_connection_statusPtr.asFunction<
          void Function(ffi.Pointer<Tox>,
              ffi.Pointer<tox_friend_connection_status_cb>)>();

  /// Check whether a friend is currently typing a message.
  ///
  /// @param friend_number The friend number for which to query the typing status.
  ///
  /// @return true if the friend is typing.
  /// @return false if the friend is not typing, or the friend number was
  /// invalid. Inspect the error code to determine which case it is.
  ///
  /// @deprecated This getter is deprecated. Use the event and store the status
  /// in the client state.
  bool tox_friend_get_typing(
    ffi.Pointer<Tox> tox,
    int friend_number,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_friend_get_typing(
          tox,
          friend_number,
          error,
        ) !=
        0;
  }

  late final _tox_friend_get_typingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint8 Function(ffi.Pointer<Tox>, ffi.Uint32,
              ffi.Pointer<ffi.Int32>)>>('tox_friend_get_typing');
  late final _tox_friend_get_typing = _tox_friend_get_typingPtr.asFunction<
      int Function(ffi.Pointer<Tox>, int, ffi.Pointer<ffi.Int32>)>();

  /// Set the callback for the `friend_typing` event. Pass NULL to unset.
  ///
  /// This event is triggered when a friend starts or stops typing.
  void tox_callback_friend_typing(
    ffi.Pointer<Tox> tox,
    ffi.Pointer<tox_friend_typing_cb> callback,
  ) {
    return _tox_callback_friend_typing(
      tox,
      callback,
    );
  }

  late final _tox_callback_friend_typingPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<Tox>, ffi.Pointer<tox_friend_typing_cb>)>>(
      'tox_callback_friend_typing');
  late final _tox_callback_friend_typing =
      _tox_callback_friend_typingPtr.asFunction<
          void Function(ffi.Pointer<Tox>, ffi.Pointer<tox_friend_typing_cb>)>();

  /// Set the client's typing status for a friend.
  ///
  /// The client is responsible for turning it on or off.
  ///
  /// @param friend_number The friend to which the client is typing a message.
  /// @param typing The typing status. True means the client is typing.
  ///
  /// @return true on success.
  bool tox_self_set_typing(
    ffi.Pointer<Tox> tox,
    int friend_number,
    bool typing,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_self_set_typing(
          tox,
          friend_number,
          typing ? 1 : 0,
          error,
        ) !=
        0;
  }

  late final _tox_self_set_typingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint8 Function(ffi.Pointer<Tox>, ffi.Uint32, ffi.Uint8,
              ffi.Pointer<ffi.Int32>)>>('tox_self_set_typing');
  late final _tox_self_set_typing = _tox_self_set_typingPtr.asFunction<
      int Function(ffi.Pointer<Tox>, int, int, ffi.Pointer<ffi.Int32>)>();

  /// Send a text chat message to an online friend.
  ///
  /// This function creates a chat message packet and pushes it into the send
  /// queue.
  ///
  /// The message length may not exceed TOX_MAX_MESSAGE_LENGTH. Larger messages
  /// must be split by the client and sent as separate messages. Other clients can
  /// then reassemble the fragments. Messages may not be empty.
  ///
  /// The return value of this function is the message ID. If a read receipt is
  /// received, the triggered `friend_read_receipt` event will be passed this message ID.
  ///
  /// Message IDs are unique per friend. The first message ID is 0. Message IDs are
  /// incremented by 1 each time a message is sent. If UINT32_MAX messages were
  /// sent, the next message ID is 0.
  ///
  /// @param type Message type (normal, action, ...).
  /// @param friend_number The friend number of the friend to send the message to.
  /// @param message A non-NULL pointer to the first element of a byte array
  /// containing the message text.
  /// @param length Length of the message to be sent.
  int tox_friend_send_message(
    ffi.Pointer<Tox> tox,
    int friend_number,
    int type,
    ffi.Pointer<ffi.Uint8> message,
    int length,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_friend_send_message(
      tox,
      friend_number,
      type,
      message,
      length,
      error,
    );
  }

  late final _tox_friend_send_messagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Pointer<Tox>,
              ffi.Uint32,
              ffi.Int32,
              ffi.Pointer<ffi.Uint8>,
              size_t,
              ffi.Pointer<ffi.Int32>)>>('tox_friend_send_message');
  late final _tox_friend_send_message = _tox_friend_send_messagePtr.asFunction<
      int Function(ffi.Pointer<Tox>, int, int, ffi.Pointer<ffi.Uint8>, int,
          ffi.Pointer<ffi.Int32>)>();

  /// Set the callback for the `friend_read_receipt` event. Pass NULL to unset.
  ///
  /// This event is triggered when the friend receives the message sent with
  /// tox_friend_send_message with the corresponding message ID.
  void tox_callback_friend_read_receipt(
    ffi.Pointer<Tox> tox,
    ffi.Pointer<tox_friend_read_receipt_cb> callback,
  ) {
    return _tox_callback_friend_read_receipt(
      tox,
      callback,
    );
  }

  late final _tox_callback_friend_read_receiptPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<Tox>, ffi.Pointer<tox_friend_read_receipt_cb>)>>(
      'tox_callback_friend_read_receipt');
  late final _tox_callback_friend_read_receipt =
      _tox_callback_friend_read_receiptPtr.asFunction<
          void Function(
              ffi.Pointer<Tox>, ffi.Pointer<tox_friend_read_receipt_cb>)>();

  /// Set the callback for the `friend_request` event. Pass NULL to unset.
  ///
  /// This event is triggered when a friend request is received.
  void tox_callback_friend_request(
    ffi.Pointer<Tox> tox,
    ffi.Pointer<tox_friend_request_cb> callback,
  ) {
    return _tox_callback_friend_request(
      tox,
      callback,
    );
  }

  late final _tox_callback_friend_requestPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<Tox>, ffi.Pointer<tox_friend_request_cb>)>>(
      'tox_callback_friend_request');
  late final _tox_callback_friend_request =
      _tox_callback_friend_requestPtr.asFunction<
          void Function(
              ffi.Pointer<Tox>, ffi.Pointer<tox_friend_request_cb>)>();

  /// Set the callback for the `friend_message` event. Pass NULL to unset.
  ///
  /// This event is triggered when a message from a friend is received.
  void tox_callback_friend_message(
    ffi.Pointer<Tox> tox,
    ffi.Pointer<tox_friend_message_cb> callback,
  ) {
    return _tox_callback_friend_message(
      tox,
      callback,
    );
  }

  late final _tox_callback_friend_messagePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<Tox>, ffi.Pointer<tox_friend_message_cb>)>>(
      'tox_callback_friend_message');
  late final _tox_callback_friend_message =
      _tox_callback_friend_messagePtr.asFunction<
          void Function(
              ffi.Pointer<Tox>, ffi.Pointer<tox_friend_message_cb>)>();

  /// Generates a cryptographic hash of the given data.
  ///
  /// This function may be used by clients for any purpose, but is provided
  /// primarily for validating cached avatars. This use is highly recommended to
  /// avoid unnecessary avatar updates.
  ///
  /// If hash is NULL or data is NULL while length is not 0 the function returns false,
  /// otherwise it returns true.
  ///
  /// This function is a wrapper to internal message-digest functions.
  ///
  /// @param hash A valid memory location the hash data. It must be at least
  /// TOX_HASH_LENGTH bytes in size.
  /// @param data Data to be hashed or NULL.
  /// @param length Size of the data array or 0.
  ///
  /// @return true if hash was not NULL.
  bool tox_hash(
    ffi.Pointer<ffi.Uint8> hash,
    ffi.Pointer<ffi.Uint8> data,
    int length,
  ) {
    return _tox_hash(
          hash,
          data,
          length,
        ) !=
        0;
  }

  late final _tox_hashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint8 Function(ffi.Pointer<ffi.Uint8>, ffi.Pointer<ffi.Uint8>,
              size_t)>>('tox_hash');
  late final _tox_hash = _tox_hashPtr.asFunction<
      int Function(ffi.Pointer<ffi.Uint8>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Sends a file control command to a friend for a given file transfer.
  ///
  /// @param friend_number The friend number of the friend the file is being
  /// transferred to or received from.
  /// @param file_number The friend-specific identifier for the file transfer.
  /// @param control The control command to send.
  ///
  /// @return true on success.
  bool tox_file_control(
    ffi.Pointer<Tox> tox,
    int friend_number,
    int file_number,
    int control,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_file_control(
          tox,
          friend_number,
          file_number,
          control,
          error,
        ) !=
        0;
  }

  late final _tox_file_controlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint8 Function(ffi.Pointer<Tox>, ffi.Uint32, ffi.Uint32,
              ffi.Int32, ffi.Pointer<ffi.Int32>)>>('tox_file_control');
  late final _tox_file_control = _tox_file_controlPtr.asFunction<
      int Function(ffi.Pointer<Tox>, int, int, int, ffi.Pointer<ffi.Int32>)>();

  /// Set the callback for the `file_recv_control` event. Pass NULL to unset.
  ///
  /// This event is triggered when a file control command is received from a
  /// friend.
  void tox_callback_file_recv_control(
    ffi.Pointer<Tox> tox,
    ffi.Pointer<tox_file_recv_control_cb> callback,
  ) {
    return _tox_callback_file_recv_control(
      tox,
      callback,
    );
  }

  late final _tox_callback_file_recv_controlPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<Tox>, ffi.Pointer<tox_file_recv_control_cb>)>>(
      'tox_callback_file_recv_control');
  late final _tox_callback_file_recv_control =
      _tox_callback_file_recv_controlPtr.asFunction<
          void Function(
              ffi.Pointer<Tox>, ffi.Pointer<tox_file_recv_control_cb>)>();

  /// Sends a file seek control command to a friend for a given file transfer.
  ///
  /// This function can only be called to resume a file transfer right before
  /// TOX_FILE_CONTROL_RESUME is sent.
  ///
  /// @param friend_number The friend number of the friend the file is being
  /// received from.
  /// @param file_number The friend-specific identifier for the file transfer.
  /// @param position The position that the file should be seeked to.
  bool tox_file_seek(
    ffi.Pointer<Tox> tox,
    int friend_number,
    int file_number,
    int position,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_file_seek(
          tox,
          friend_number,
          file_number,
          position,
          error,
        ) !=
        0;
  }

  late final _tox_file_seekPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint8 Function(ffi.Pointer<Tox>, ffi.Uint32, ffi.Uint32,
              ffi.Uint64, ffi.Pointer<ffi.Int32>)>>('tox_file_seek');
  late final _tox_file_seek = _tox_file_seekPtr.asFunction<
      int Function(ffi.Pointer<Tox>, int, int, int, ffi.Pointer<ffi.Int32>)>();

  /// Copy the file id associated to the file transfer to a byte array.
  ///
  /// @param friend_number The friend number of the friend the file is being
  /// transferred to or received from.
  /// @param file_number The friend-specific identifier for the file transfer.
  /// @param file_id A memory region of at least TOX_FILE_ID_LENGTH bytes. If
  /// this parameter is NULL, this function has no effect.
  ///
  /// @return true on success.
  bool tox_file_get_file_id(
    ffi.Pointer<Tox> tox,
    int friend_number,
    int file_number,
    ffi.Pointer<ffi.Uint8> file_id,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_file_get_file_id(
          tox,
          friend_number,
          file_number,
          file_id,
          error,
        ) !=
        0;
  }

  late final _tox_file_get_file_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint8 Function(
              ffi.Pointer<Tox>,
              ffi.Uint32,
              ffi.Uint32,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Int32>)>>('tox_file_get_file_id');
  late final _tox_file_get_file_id = _tox_file_get_file_idPtr.asFunction<
      int Function(ffi.Pointer<Tox>, int, int, ffi.Pointer<ffi.Uint8>,
          ffi.Pointer<ffi.Int32>)>();

  /// Send a file transmission request.
  ///
  /// Maximum filename length is TOX_MAX_FILENAME_LENGTH bytes. The filename
  /// should generally just be a file name, not a path with directory names.
  ///
  /// If a non-UINT64_MAX file size is provided, it can be used by both sides to
  /// determine the sending progress. File size can be set to UINT64_MAX for streaming
  /// data of unknown size.
  ///
  /// File transmission occurs in chunks, which are requested through the
  /// `file_chunk_request` event.
  ///
  /// When a friend goes offline, all file transfers associated with the friend are
  /// purged from core.
  ///
  /// If the file contents change during a transfer, the behaviour is unspecified
  /// in general. What will actually happen depends on the mode in which the file
  /// was modified and how the client determines the file size.
  ///
  /// - If the file size was increased
  /// - and sending mode was streaming (file_size = UINT64_MAX), the behaviour
  /// will be as expected.
  /// - and sending mode was file (file_size != UINT64_MAX), the
  /// file_chunk_request callback will receive length = 0 when Core thinks
  /// the file transfer has finished. If the client remembers the file size as
  /// it was when sending the request, it will terminate the transfer normally.
  /// If the client re-reads the size, it will think the friend cancelled the
  /// transfer.
  /// - If the file size was decreased
  /// - and sending mode was streaming, the behaviour is as expected.
  /// - and sending mode was file, the callback will return 0 at the new
  /// (earlier) end-of-file, signalling to the friend that the transfer was
  /// cancelled.
  /// - If the file contents were modified
  /// - at a position before the current read, the two files (local and remote)
  /// will differ after the transfer terminates.
  /// - at a position after the current read, the file transfer will succeed as
  /// expected.
  /// - In either case, both sides will regard the transfer as complete and
  /// successful.
  ///
  /// @param friend_number The friend number of the friend the file send request
  /// should be sent to.
  /// @param kind The meaning of the file to be sent.
  /// @param file_size Size in bytes of the file the client wants to send, UINT64_MAX if
  /// unknown or streaming.
  /// @param file_id A file identifier of length TOX_FILE_ID_LENGTH that can be used to
  /// uniquely identify file transfers across core restarts. If NULL, a random one will
  /// be generated by core. It can then be obtained by using tox_file_get_file_id().
  /// @param filename Name of the file. Does not need to be the actual name. This
  /// name will be sent along with the file send request.
  /// @param filename_length Size in bytes of the filename.
  ///
  /// @return A file number used as an identifier in subsequent callbacks. This
  /// number is per friend. File numbers are reused after a transfer terminates.
  /// On failure, this function returns an unspecified value. Any pattern in file numbers
  /// should not be relied on.
  int tox_file_send(
    ffi.Pointer<Tox> tox,
    int friend_number,
    int kind,
    int file_size,
    ffi.Pointer<ffi.Uint8> file_id,
    ffi.Pointer<ffi.Uint8> filename,
    int filename_length,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_file_send(
      tox,
      friend_number,
      kind,
      file_size,
      file_id,
      filename,
      filename_length,
      error,
    );
  }

  late final _tox_file_sendPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Pointer<Tox>,
              ffi.Uint32,
              ffi.Uint32,
              ffi.Uint64,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Uint8>,
              size_t,
              ffi.Pointer<ffi.Int32>)>>('tox_file_send');
  late final _tox_file_send = _tox_file_sendPtr.asFunction<
      int Function(ffi.Pointer<Tox>, int, int, int, ffi.Pointer<ffi.Uint8>,
          ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Int32>)>();

  /// Send a chunk of file data to a friend.
  ///
  /// This function is called in response to the `file_chunk_request` callback. The
  /// length parameter should be equal to the one received though the callback.
  /// If it is zero, the transfer is assumed complete. For files with known size,
  /// Core will know that the transfer is complete after the last byte has been
  /// received, so it is not necessary (though not harmful) to send a zero-length
  /// chunk to terminate. For streams, core will know that the transfer is finished
  /// if a chunk with length less than the length requested in the callback is sent.
  ///
  /// @param friend_number The friend number of the receiving friend for this file.
  /// @param file_number The file transfer identifier returned by tox_file_send.
  /// @param position The file or stream position from which to continue reading.
  /// @return true on success.
  bool tox_file_send_chunk(
    ffi.Pointer<Tox> tox,
    int friend_number,
    int file_number,
    int position,
    ffi.Pointer<ffi.Uint8> data,
    int length,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_file_send_chunk(
          tox,
          friend_number,
          file_number,
          position,
          data,
          length,
          error,
        ) !=
        0;
  }

  late final _tox_file_send_chunkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint8 Function(
              ffi.Pointer<Tox>,
              ffi.Uint32,
              ffi.Uint32,
              ffi.Uint64,
              ffi.Pointer<ffi.Uint8>,
              size_t,
              ffi.Pointer<ffi.Int32>)>>('tox_file_send_chunk');
  late final _tox_file_send_chunk = _tox_file_send_chunkPtr.asFunction<
      int Function(ffi.Pointer<Tox>, int, int, int, ffi.Pointer<ffi.Uint8>, int,
          ffi.Pointer<ffi.Int32>)>();

  /// Set the callback for the `file_chunk_request` event. Pass NULL to unset.
  ///
  /// This event is triggered when Core is ready to send more file data.
  void tox_callback_file_chunk_request(
    ffi.Pointer<Tox> tox,
    ffi.Pointer<tox_file_chunk_request_cb> callback,
  ) {
    return _tox_callback_file_chunk_request(
      tox,
      callback,
    );
  }

  late final _tox_callback_file_chunk_requestPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<Tox>, ffi.Pointer<tox_file_chunk_request_cb>)>>(
      'tox_callback_file_chunk_request');
  late final _tox_callback_file_chunk_request =
      _tox_callback_file_chunk_requestPtr.asFunction<
          void Function(
              ffi.Pointer<Tox>, ffi.Pointer<tox_file_chunk_request_cb>)>();

  /// Set the callback for the `file_recv` event. Pass NULL to unset.
  ///
  /// This event is triggered when a file transfer request is received.
  void tox_callback_file_recv(
    ffi.Pointer<Tox> tox,
    ffi.Pointer<tox_file_recv_cb> callback,
  ) {
    return _tox_callback_file_recv(
      tox,
      callback,
    );
  }

  late final _tox_callback_file_recvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<Tox>,
              ffi.Pointer<tox_file_recv_cb>)>>('tox_callback_file_recv');
  late final _tox_callback_file_recv = _tox_callback_file_recvPtr.asFunction<
      void Function(ffi.Pointer<Tox>, ffi.Pointer<tox_file_recv_cb>)>();

  /// Set the callback for the `file_recv_chunk` event. Pass NULL to unset.
  ///
  /// This event is first triggered when a file transfer request is received, and
  /// subsequently when a chunk of file data for an accepted request was received.
  void tox_callback_file_recv_chunk(
    ffi.Pointer<Tox> tox,
    ffi.Pointer<tox_file_recv_chunk_cb> callback,
  ) {
    return _tox_callback_file_recv_chunk(
      tox,
      callback,
    );
  }

  late final _tox_callback_file_recv_chunkPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<Tox>, ffi.Pointer<tox_file_recv_chunk_cb>)>>(
      'tox_callback_file_recv_chunk');
  late final _tox_callback_file_recv_chunk =
      _tox_callback_file_recv_chunkPtr.asFunction<
          void Function(
              ffi.Pointer<Tox>, ffi.Pointer<tox_file_recv_chunk_cb>)>();

  /// Set the callback for the `conference_invite` event. Pass NULL to unset.
  ///
  /// This event is triggered when the client is invited to join a conference.
  void tox_callback_conference_invite(
    ffi.Pointer<Tox> tox,
    ffi.Pointer<tox_conference_invite_cb> callback,
  ) {
    return _tox_callback_conference_invite(
      tox,
      callback,
    );
  }

  late final _tox_callback_conference_invitePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<Tox>, ffi.Pointer<tox_conference_invite_cb>)>>(
      'tox_callback_conference_invite');
  late final _tox_callback_conference_invite =
      _tox_callback_conference_invitePtr.asFunction<
          void Function(
              ffi.Pointer<Tox>, ffi.Pointer<tox_conference_invite_cb>)>();

  /// Set the callback for the `conference_connected` event. Pass NULL to unset.
  ///
  /// This event is triggered when the client successfully connects to a
  /// conference after joining it with the tox_conference_join function.
  void tox_callback_conference_connected(
    ffi.Pointer<Tox> tox,
    ffi.Pointer<tox_conference_connected_cb> callback,
  ) {
    return _tox_callback_conference_connected(
      tox,
      callback,
    );
  }

  late final _tox_callback_conference_connectedPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<Tox>, ffi.Pointer<tox_conference_connected_cb>)>>(
      'tox_callback_conference_connected');
  late final _tox_callback_conference_connected =
      _tox_callback_conference_connectedPtr.asFunction<
          void Function(
              ffi.Pointer<Tox>, ffi.Pointer<tox_conference_connected_cb>)>();

  /// Set the callback for the `conference_message` event. Pass NULL to unset.
  ///
  /// This event is triggered when the client receives a conference message.
  void tox_callback_conference_message(
    ffi.Pointer<Tox> tox,
    ffi.Pointer<tox_conference_message_cb> callback,
  ) {
    return _tox_callback_conference_message(
      tox,
      callback,
    );
  }

  late final _tox_callback_conference_messagePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<Tox>, ffi.Pointer<tox_conference_message_cb>)>>(
      'tox_callback_conference_message');
  late final _tox_callback_conference_message =
      _tox_callback_conference_messagePtr.asFunction<
          void Function(
              ffi.Pointer<Tox>, ffi.Pointer<tox_conference_message_cb>)>();

  /// Set the callback for the `conference_title` event. Pass NULL to unset.
  ///
  /// This event is triggered when a peer changes the conference title.
  ///
  /// If peer_number == UINT32_MAX, then author is unknown (e.g. initial joining the conference).
  void tox_callback_conference_title(
    ffi.Pointer<Tox> tox,
    ffi.Pointer<tox_conference_title_cb> callback,
  ) {
    return _tox_callback_conference_title(
      tox,
      callback,
    );
  }

  late final _tox_callback_conference_titlePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<Tox>, ffi.Pointer<tox_conference_title_cb>)>>(
      'tox_callback_conference_title');
  late final _tox_callback_conference_title =
      _tox_callback_conference_titlePtr.asFunction<
          void Function(
              ffi.Pointer<Tox>, ffi.Pointer<tox_conference_title_cb>)>();

  /// Set the callback for the `conference_peer_name` event. Pass NULL to unset.
  ///
  /// This event is triggered when a peer changes their name.
  void tox_callback_conference_peer_name(
    ffi.Pointer<Tox> tox,
    ffi.Pointer<tox_conference_peer_name_cb> callback,
  ) {
    return _tox_callback_conference_peer_name(
      tox,
      callback,
    );
  }

  late final _tox_callback_conference_peer_namePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<Tox>, ffi.Pointer<tox_conference_peer_name_cb>)>>(
      'tox_callback_conference_peer_name');
  late final _tox_callback_conference_peer_name =
      _tox_callback_conference_peer_namePtr.asFunction<
          void Function(
              ffi.Pointer<Tox>, ffi.Pointer<tox_conference_peer_name_cb>)>();

  /// Set the callback for the `conference_peer_list_changed` event. Pass NULL to unset.
  ///
  /// This event is triggered when a peer joins or leaves the conference.
  void tox_callback_conference_peer_list_changed(
    ffi.Pointer<Tox> tox,
    ffi.Pointer<tox_conference_peer_list_changed_cb> callback,
  ) {
    return _tox_callback_conference_peer_list_changed(
      tox,
      callback,
    );
  }

  late final _tox_callback_conference_peer_list_changedPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<Tox>,
                  ffi.Pointer<tox_conference_peer_list_changed_cb>)>>(
      'tox_callback_conference_peer_list_changed');
  late final _tox_callback_conference_peer_list_changed =
      _tox_callback_conference_peer_list_changedPtr.asFunction<
          void Function(ffi.Pointer<Tox>,
              ffi.Pointer<tox_conference_peer_list_changed_cb>)>();

  /// Creates a new conference.
  ///
  /// This function creates and connects to a new text conference.
  ///
  /// @return conference number on success, or an unspecified value on failure.
  int tox_conference_new(
    ffi.Pointer<Tox> tox,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_conference_new(
      tox,
      error,
    );
  }

  late final _tox_conference_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Pointer<Tox>, ffi.Pointer<ffi.Int32>)>>('tox_conference_new');
  late final _tox_conference_new = _tox_conference_newPtr
      .asFunction<int Function(ffi.Pointer<Tox>, ffi.Pointer<ffi.Int32>)>();

  /// This function deletes a conference.
  ///
  /// @param conference_number The conference number of the conference to be deleted.
  ///
  /// @return true on success.
  bool tox_conference_delete(
    ffi.Pointer<Tox> tox,
    int conference_number,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_conference_delete(
          tox,
          conference_number,
          error,
        ) !=
        0;
  }

  late final _tox_conference_deletePtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint8 Function(ffi.Pointer<Tox>, ffi.Uint32,
              ffi.Pointer<ffi.Int32>)>>('tox_conference_delete');
  late final _tox_conference_delete = _tox_conference_deletePtr.asFunction<
      int Function(ffi.Pointer<Tox>, int, ffi.Pointer<ffi.Int32>)>();

  /// Return the number of online peers in the conference. The unsigned
  /// integers less than this number are the valid values of peer_number for
  /// the functions querying these peers. Return value is unspecified on
  /// failure.
  int tox_conference_peer_count(
    ffi.Pointer<Tox> tox,
    int conference_number,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_conference_peer_count(
      tox,
      conference_number,
      error,
    );
  }

  late final _tox_conference_peer_countPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(ffi.Pointer<Tox>, ffi.Uint32,
              ffi.Pointer<ffi.Int32>)>>('tox_conference_peer_count');
  late final _tox_conference_peer_count =
      _tox_conference_peer_countPtr.asFunction<
          int Function(ffi.Pointer<Tox>, int, ffi.Pointer<ffi.Int32>)>();

  /// Return the length of the peer's name. Return value is unspecified on failure.
  int tox_conference_peer_get_name_size(
    ffi.Pointer<Tox> tox,
    int conference_number,
    int peer_number,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_conference_peer_get_name_size(
      tox,
      conference_number,
      peer_number,
      error,
    );
  }

  late final _tox_conference_peer_get_name_sizePtr = _lookup<
      ffi.NativeFunction<
          size_t Function(ffi.Pointer<Tox>, ffi.Uint32, ffi.Uint32,
              ffi.Pointer<ffi.Int32>)>>('tox_conference_peer_get_name_size');
  late final _tox_conference_peer_get_name_size =
      _tox_conference_peer_get_name_sizePtr.asFunction<
          int Function(ffi.Pointer<Tox>, int, int, ffi.Pointer<ffi.Int32>)>();

  /// Copy the name of peer_number who is in conference_number to name.
  ///
  /// Call tox_conference_peer_get_name_size to determine the allocation size for the `name` parameter.
  ///
  /// @param name A valid memory region large enough to store the peer's name.
  ///
  /// @return true on success.
  bool tox_conference_peer_get_name(
    ffi.Pointer<Tox> tox,
    int conference_number,
    int peer_number,
    ffi.Pointer<ffi.Uint8> name,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_conference_peer_get_name(
          tox,
          conference_number,
          peer_number,
          name,
          error,
        ) !=
        0;
  }

  late final _tox_conference_peer_get_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint8 Function(
              ffi.Pointer<Tox>,
              ffi.Uint32,
              ffi.Uint32,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Int32>)>>('tox_conference_peer_get_name');
  late final _tox_conference_peer_get_name =
      _tox_conference_peer_get_namePtr.asFunction<
          int Function(ffi.Pointer<Tox>, int, int, ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Int32>)>();

  /// Copy the public key of peer_number who is in conference_number to public_key.
  /// public_key must be TOX_PUBLIC_KEY_SIZE long.
  ///
  /// @return true on success.
  bool tox_conference_peer_get_public_key(
    ffi.Pointer<Tox> tox,
    int conference_number,
    int peer_number,
    ffi.Pointer<ffi.Uint8> public_key,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_conference_peer_get_public_key(
          tox,
          conference_number,
          peer_number,
          public_key,
          error,
        ) !=
        0;
  }

  late final _tox_conference_peer_get_public_keyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint8 Function(
              ffi.Pointer<Tox>,
              ffi.Uint32,
              ffi.Uint32,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Int32>)>>('tox_conference_peer_get_public_key');
  late final _tox_conference_peer_get_public_key =
      _tox_conference_peer_get_public_keyPtr.asFunction<
          int Function(ffi.Pointer<Tox>, int, int, ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Int32>)>();

  /// Return true if passed peer_number corresponds to our own.
  bool tox_conference_peer_number_is_ours(
    ffi.Pointer<Tox> tox,
    int conference_number,
    int peer_number,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_conference_peer_number_is_ours(
          tox,
          conference_number,
          peer_number,
          error,
        ) !=
        0;
  }

  late final _tox_conference_peer_number_is_oursPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint8 Function(ffi.Pointer<Tox>, ffi.Uint32, ffi.Uint32,
              ffi.Pointer<ffi.Int32>)>>('tox_conference_peer_number_is_ours');
  late final _tox_conference_peer_number_is_ours =
      _tox_conference_peer_number_is_oursPtr.asFunction<
          int Function(ffi.Pointer<Tox>, int, int, ffi.Pointer<ffi.Int32>)>();

  /// Return the number of offline peers in the conference. The unsigned
  /// integers less than this number are the valid values of offline_peer_number for
  /// the functions querying these peers. Return value is unspecified on failure.
  int tox_conference_offline_peer_count(
    ffi.Pointer<Tox> tox,
    int conference_number,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_conference_offline_peer_count(
      tox,
      conference_number,
      error,
    );
  }

  late final _tox_conference_offline_peer_countPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(ffi.Pointer<Tox>, ffi.Uint32,
              ffi.Pointer<ffi.Int32>)>>('tox_conference_offline_peer_count');
  late final _tox_conference_offline_peer_count =
      _tox_conference_offline_peer_countPtr.asFunction<
          int Function(ffi.Pointer<Tox>, int, ffi.Pointer<ffi.Int32>)>();

  /// Return the length of the offline peer's name. Return value is unspecified on failure.
  int tox_conference_offline_peer_get_name_size(
    ffi.Pointer<Tox> tox,
    int conference_number,
    int offline_peer_number,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_conference_offline_peer_get_name_size(
      tox,
      conference_number,
      offline_peer_number,
      error,
    );
  }

  late final _tox_conference_offline_peer_get_name_sizePtr = _lookup<
          ffi.NativeFunction<
              size_t Function(ffi.Pointer<Tox>, ffi.Uint32, ffi.Uint32,
                  ffi.Pointer<ffi.Int32>)>>(
      'tox_conference_offline_peer_get_name_size');
  late final _tox_conference_offline_peer_get_name_size =
      _tox_conference_offline_peer_get_name_sizePtr.asFunction<
          int Function(ffi.Pointer<Tox>, int, int, ffi.Pointer<ffi.Int32>)>();

  /// Copy the name of offline_peer_number who is in conference_number to name.
  ///
  /// Call tox_conference_offline_peer_get_name_size to determine the allocation size for the `name` parameter.
  ///
  /// @param name A valid memory region large enough to store the peer's name.
  ///
  /// @return true on success.
  bool tox_conference_offline_peer_get_name(
    ffi.Pointer<Tox> tox,
    int conference_number,
    int offline_peer_number,
    ffi.Pointer<ffi.Uint8> name,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_conference_offline_peer_get_name(
          tox,
          conference_number,
          offline_peer_number,
          name,
          error,
        ) !=
        0;
  }

  late final _tox_conference_offline_peer_get_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint8 Function(
              ffi.Pointer<Tox>,
              ffi.Uint32,
              ffi.Uint32,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Int32>)>>('tox_conference_offline_peer_get_name');
  late final _tox_conference_offline_peer_get_name =
      _tox_conference_offline_peer_get_namePtr.asFunction<
          int Function(ffi.Pointer<Tox>, int, int, ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Int32>)>();

  /// Copy the public key of offline_peer_number who is in conference_number to public_key.
  /// public_key must be TOX_PUBLIC_KEY_SIZE long.
  ///
  /// @return true on success.
  bool tox_conference_offline_peer_get_public_key(
    ffi.Pointer<Tox> tox,
    int conference_number,
    int offline_peer_number,
    ffi.Pointer<ffi.Uint8> public_key,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_conference_offline_peer_get_public_key(
          tox,
          conference_number,
          offline_peer_number,
          public_key,
          error,
        ) !=
        0;
  }

  late final _tox_conference_offline_peer_get_public_keyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint8 Function(ffi.Pointer<Tox>, ffi.Uint32, ffi.Uint32,
                  ffi.Pointer<ffi.Uint8>, ffi.Pointer<ffi.Int32>)>>(
      'tox_conference_offline_peer_get_public_key');
  late final _tox_conference_offline_peer_get_public_key =
      _tox_conference_offline_peer_get_public_keyPtr.asFunction<
          int Function(ffi.Pointer<Tox>, int, int, ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Int32>)>();

  /// Return a unix-time timestamp of the last time offline_peer_number was seen to be active.
  int tox_conference_offline_peer_get_last_active(
    ffi.Pointer<Tox> tox,
    int conference_number,
    int offline_peer_number,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_conference_offline_peer_get_last_active(
      tox,
      conference_number,
      offline_peer_number,
      error,
    );
  }

  late final _tox_conference_offline_peer_get_last_activePtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<Tox>, ffi.Uint32, ffi.Uint32,
                  ffi.Pointer<ffi.Int32>)>>(
      'tox_conference_offline_peer_get_last_active');
  late final _tox_conference_offline_peer_get_last_active =
      _tox_conference_offline_peer_get_last_activePtr.asFunction<
          int Function(ffi.Pointer<Tox>, int, int, ffi.Pointer<ffi.Int32>)>();

  /// Set maximum number of offline peers to store, overriding the default.
  bool tox_conference_set_max_offline(
    ffi.Pointer<Tox> tox,
    int conference_number,
    int max_offline_peers,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_conference_set_max_offline(
          tox,
          conference_number,
          max_offline_peers,
          error,
        ) !=
        0;
  }

  late final _tox_conference_set_max_offlinePtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint8 Function(ffi.Pointer<Tox>, ffi.Uint32, ffi.Uint32,
              ffi.Pointer<ffi.Int32>)>>('tox_conference_set_max_offline');
  late final _tox_conference_set_max_offline =
      _tox_conference_set_max_offlinePtr.asFunction<
          int Function(ffi.Pointer<Tox>, int, int, ffi.Pointer<ffi.Int32>)>();

  /// Invites a friend to a conference.
  ///
  /// @param friend_number The friend number of the friend we want to invite.
  /// @param conference_number The conference number of the conference we want to invite the friend to.
  ///
  /// @return true on success.
  bool tox_conference_invite(
    ffi.Pointer<Tox> tox,
    int friend_number,
    int conference_number,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_conference_invite(
          tox,
          friend_number,
          conference_number,
          error,
        ) !=
        0;
  }

  late final _tox_conference_invitePtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint8 Function(ffi.Pointer<Tox>, ffi.Uint32, ffi.Uint32,
              ffi.Pointer<ffi.Int32>)>>('tox_conference_invite');
  late final _tox_conference_invite = _tox_conference_invitePtr.asFunction<
      int Function(ffi.Pointer<Tox>, int, int, ffi.Pointer<ffi.Int32>)>();

  /// Joins a conference that the client has been invited to.
  ///
  /// After successfully joining the conference, the client will not be "connected"
  /// to it until a handshaking procedure has been completed. A
  /// `conference_connected` event will then occur for the conference. The client
  /// will then remain connected to the conference until the conference is deleted,
  /// even across core restarts. Many operations on a conference will fail with a
  /// corresponding error if attempted on a conference to which the client is not
  /// yet connected.
  ///
  /// @param friend_number The friend number of the friend who sent the invite.
  /// @param cookie Received via the `conference_invite` event.
  /// @param length The size of cookie.
  ///
  /// @return conference number on success, an unspecified value on failure.
  int tox_conference_join(
    ffi.Pointer<Tox> tox,
    int friend_number,
    ffi.Pointer<ffi.Uint8> cookie,
    int length,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_conference_join(
      tox,
      friend_number,
      cookie,
      length,
      error,
    );
  }

  late final _tox_conference_joinPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Pointer<Tox>,
              ffi.Uint32,
              ffi.Pointer<ffi.Uint8>,
              size_t,
              ffi.Pointer<ffi.Int32>)>>('tox_conference_join');
  late final _tox_conference_join = _tox_conference_joinPtr.asFunction<
      int Function(ffi.Pointer<Tox>, int, ffi.Pointer<ffi.Uint8>, int,
          ffi.Pointer<ffi.Int32>)>();

  /// Send a text chat message to the conference.
  ///
  /// This function creates a conference message packet and pushes it into the send
  /// queue.
  ///
  /// The message length may not exceed TOX_MAX_MESSAGE_LENGTH. Larger messages
  /// must be split by the client and sent as separate messages. Other clients can
  /// then reassemble the fragments.
  ///
  /// @param conference_number The conference number of the conference the message is intended for.
  /// @param type Message type (normal, action, ...).
  /// @param message A non-NULL pointer to the first element of a byte array
  /// containing the message text.
  /// @param length Length of the message to be sent.
  ///
  /// @return true on success.
  bool tox_conference_send_message(
    ffi.Pointer<Tox> tox,
    int conference_number,
    int type,
    ffi.Pointer<ffi.Uint8> message,
    int length,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_conference_send_message(
          tox,
          conference_number,
          type,
          message,
          length,
          error,
        ) !=
        0;
  }

  late final _tox_conference_send_messagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint8 Function(
              ffi.Pointer<Tox>,
              ffi.Uint32,
              ffi.Int32,
              ffi.Pointer<ffi.Uint8>,
              size_t,
              ffi.Pointer<ffi.Int32>)>>('tox_conference_send_message');
  late final _tox_conference_send_message =
      _tox_conference_send_messagePtr.asFunction<
          int Function(ffi.Pointer<Tox>, int, int, ffi.Pointer<ffi.Uint8>, int,
              ffi.Pointer<ffi.Int32>)>();

  /// Return the length of the conference title. Return value is unspecified on failure.
  ///
  /// The return value is equal to the `length` argument received by the last
  /// `conference_title` callback.
  int tox_conference_get_title_size(
    ffi.Pointer<Tox> tox,
    int conference_number,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_conference_get_title_size(
      tox,
      conference_number,
      error,
    );
  }

  late final _tox_conference_get_title_sizePtr = _lookup<
      ffi.NativeFunction<
          size_t Function(ffi.Pointer<Tox>, ffi.Uint32,
              ffi.Pointer<ffi.Int32>)>>('tox_conference_get_title_size');
  late final _tox_conference_get_title_size =
      _tox_conference_get_title_sizePtr.asFunction<
          int Function(ffi.Pointer<Tox>, int, ffi.Pointer<ffi.Int32>)>();

  /// Write the title designated by the given conference number to a byte array.
  ///
  /// Call tox_conference_get_title_size to determine the allocation size for the `title` parameter.
  ///
  /// The data written to `title` is equal to the data received by the last
  /// `conference_title` callback.
  ///
  /// @param title A valid memory region large enough to store the title.
  /// If this parameter is NULL, this function has no effect.
  ///
  /// @return true on success.
  bool tox_conference_get_title(
    ffi.Pointer<Tox> tox,
    int conference_number,
    ffi.Pointer<ffi.Uint8> title,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_conference_get_title(
          tox,
          conference_number,
          title,
          error,
        ) !=
        0;
  }

  late final _tox_conference_get_titlePtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint8 Function(
              ffi.Pointer<Tox>,
              ffi.Uint32,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Int32>)>>('tox_conference_get_title');
  late final _tox_conference_get_title =
      _tox_conference_get_titlePtr.asFunction<
          int Function(ffi.Pointer<Tox>, int, ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Int32>)>();

  /// Set the conference title and broadcast it to the rest of the conference.
  ///
  /// Title length cannot be longer than TOX_MAX_NAME_LENGTH.
  ///
  /// @return true on success.
  bool tox_conference_set_title(
    ffi.Pointer<Tox> tox,
    int conference_number,
    ffi.Pointer<ffi.Uint8> title,
    int length,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_conference_set_title(
          tox,
          conference_number,
          title,
          length,
          error,
        ) !=
        0;
  }

  late final _tox_conference_set_titlePtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint8 Function(
              ffi.Pointer<Tox>,
              ffi.Uint32,
              ffi.Pointer<ffi.Uint8>,
              size_t,
              ffi.Pointer<ffi.Int32>)>>('tox_conference_set_title');
  late final _tox_conference_set_title =
      _tox_conference_set_titlePtr.asFunction<
          int Function(ffi.Pointer<Tox>, int, ffi.Pointer<ffi.Uint8>, int,
              ffi.Pointer<ffi.Int32>)>();

  /// Return the number of conferences in the Tox instance.
  /// This should be used to determine how much memory to allocate for `tox_conference_get_chatlist`.
  int tox_conference_get_chatlist_size(
    ffi.Pointer<Tox> tox,
  ) {
    return _tox_conference_get_chatlist_size(
      tox,
    );
  }

  late final _tox_conference_get_chatlist_sizePtr =
      _lookup<ffi.NativeFunction<size_t Function(ffi.Pointer<Tox>)>>(
          'tox_conference_get_chatlist_size');
  late final _tox_conference_get_chatlist_size =
      _tox_conference_get_chatlist_sizePtr
          .asFunction<int Function(ffi.Pointer<Tox>)>();

  /// Copy a list of valid conference numbers into the array chatlist. Determine
  /// how much space to allocate for the array with the `tox_conference_get_chatlist_size` function.
  ///
  /// Note that `tox_get_savedata` saves all connected conferences;
  /// when toxcore is created from savedata in which conferences were saved, those
  /// conferences will be connected at startup, and will be listed by
  /// `tox_conference_get_chatlist`.
  ///
  /// The conference number of a loaded conference may differ from the conference
  /// number it had when it was saved.
  void tox_conference_get_chatlist(
    ffi.Pointer<Tox> tox,
    ffi.Pointer<ffi.Uint32> chatlist,
  ) {
    return _tox_conference_get_chatlist(
      tox,
      chatlist,
    );
  }

  late final _tox_conference_get_chatlistPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<Tox>,
              ffi.Pointer<ffi.Uint32>)>>('tox_conference_get_chatlist');
  late final _tox_conference_get_chatlist = _tox_conference_get_chatlistPtr
      .asFunction<void Function(ffi.Pointer<Tox>, ffi.Pointer<ffi.Uint32>)>();

  int tox_conference_get_type(
    ffi.Pointer<Tox> tox,
    int conference_number,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_conference_get_type(
      tox,
      conference_number,
      error,
    );
  }

  late final _tox_conference_get_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<Tox>, ffi.Uint32,
              ffi.Pointer<ffi.Int32>)>>('tox_conference_get_type');
  late final _tox_conference_get_type = _tox_conference_get_typePtr.asFunction<
      int Function(ffi.Pointer<Tox>, int, ffi.Pointer<ffi.Int32>)>();

  /// Get the conference unique ID.
  ///
  /// If id is NULL, this function has no effect.
  ///
  /// @param id A memory region large enough to store TOX_CONFERENCE_ID_SIZE bytes.
  ///
  /// @return true on success.
  bool tox_conference_get_id(
    ffi.Pointer<Tox> tox,
    int conference_number,
    ffi.Pointer<ffi.Uint8> id,
  ) {
    return _tox_conference_get_id(
          tox,
          conference_number,
          id,
        ) !=
        0;
  }

  late final _tox_conference_get_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint8 Function(ffi.Pointer<Tox>, ffi.Uint32,
              ffi.Pointer<ffi.Uint8>)>>('tox_conference_get_id');
  late final _tox_conference_get_id = _tox_conference_get_idPtr.asFunction<
      int Function(ffi.Pointer<Tox>, int, ffi.Pointer<ffi.Uint8>)>();

  /// Return the conference number associated with the specified id.
  ///
  /// @param id A byte array containing the conference id (TOX_CONFERENCE_ID_SIZE).
  ///
  /// @return the conference number on success, an unspecified value on failure.
  int tox_conference_by_id(
    ffi.Pointer<Tox> tox,
    ffi.Pointer<ffi.Uint8> id,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_conference_by_id(
      tox,
      id,
      error,
    );
  }

  late final _tox_conference_by_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(ffi.Pointer<Tox>, ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Int32>)>>('tox_conference_by_id');
  late final _tox_conference_by_id = _tox_conference_by_idPtr.asFunction<
      int Function(
          ffi.Pointer<Tox>, ffi.Pointer<ffi.Uint8>, ffi.Pointer<ffi.Int32>)>();

  /// Get the conference unique ID.
  ///
  /// If uid is NULL, this function has no effect.
  ///
  /// @param uid A memory region large enough to store TOX_CONFERENCE_UID_SIZE bytes.
  ///
  /// @return true on success.
  /// @deprecated use tox_conference_get_id instead (exactly the same function, just renamed).
  bool tox_conference_get_uid(
    ffi.Pointer<Tox> tox,
    int conference_number,
    ffi.Pointer<ffi.Uint8> uid,
  ) {
    return _tox_conference_get_uid(
          tox,
          conference_number,
          uid,
        ) !=
        0;
  }

  late final _tox_conference_get_uidPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint8 Function(ffi.Pointer<Tox>, ffi.Uint32,
              ffi.Pointer<ffi.Uint8>)>>('tox_conference_get_uid');
  late final _tox_conference_get_uid = _tox_conference_get_uidPtr.asFunction<
      int Function(ffi.Pointer<Tox>, int, ffi.Pointer<ffi.Uint8>)>();

  /// Return the conference number associated with the specified uid.
  ///
  /// @param uid A byte array containing the conference id (TOX_CONFERENCE_UID_SIZE).
  ///
  /// @return the conference number on success, an unspecified value on failure.
  /// @deprecated use tox_conference_by_id instead (exactly the same function, just renamed).
  int tox_conference_by_uid(
    ffi.Pointer<Tox> tox,
    ffi.Pointer<ffi.Uint8> uid,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_conference_by_uid(
      tox,
      uid,
      error,
    );
  }

  late final _tox_conference_by_uidPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(ffi.Pointer<Tox>, ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Int32>)>>('tox_conference_by_uid');
  late final _tox_conference_by_uid = _tox_conference_by_uidPtr.asFunction<
      int Function(
          ffi.Pointer<Tox>, ffi.Pointer<ffi.Uint8>, ffi.Pointer<ffi.Int32>)>();

  /// Send a custom lossy packet to a friend.
  ///
  /// The first byte of data must be in the range 192-254. Maximum length of a
  /// custom packet is TOX_MAX_CUSTOM_PACKET_SIZE.
  ///
  /// Lossy packets behave like UDP packets, meaning they might never reach the
  /// other side or might arrive more than once (if someone is messing with the
  /// connection) or might arrive in the wrong order.
  ///
  /// Unless latency is an issue, it is recommended that you use lossless custom
  /// packets instead.
  ///
  /// @param friend_number The friend number of the friend this lossy packet
  /// should be sent to.
  /// @param data A byte array containing the packet data.
  /// @param length The length of the packet data byte array.
  ///
  /// @return true on success.
  bool tox_friend_send_lossy_packet(
    ffi.Pointer<Tox> tox,
    int friend_number,
    ffi.Pointer<ffi.Uint8> data,
    int length,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_friend_send_lossy_packet(
          tox,
          friend_number,
          data,
          length,
          error,
        ) !=
        0;
  }

  late final _tox_friend_send_lossy_packetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint8 Function(
              ffi.Pointer<Tox>,
              ffi.Uint32,
              ffi.Pointer<ffi.Uint8>,
              size_t,
              ffi.Pointer<ffi.Int32>)>>('tox_friend_send_lossy_packet');
  late final _tox_friend_send_lossy_packet =
      _tox_friend_send_lossy_packetPtr.asFunction<
          int Function(ffi.Pointer<Tox>, int, ffi.Pointer<ffi.Uint8>, int,
              ffi.Pointer<ffi.Int32>)>();

  /// Send a custom lossless packet to a friend.
  ///
  /// The first byte of data must be in the range 69, 160-191. Maximum length of a
  /// custom packet is TOX_MAX_CUSTOM_PACKET_SIZE.
  ///
  /// Lossless packet behaviour is comparable to TCP (reliability, arrive in order)
  /// but with packets instead of a stream.
  ///
  /// @param friend_number The friend number of the friend this lossless packet
  /// should be sent to.
  /// @param data A byte array containing the packet data.
  /// @param length The length of the packet data byte array.
  ///
  /// @return true on success.
  bool tox_friend_send_lossless_packet(
    ffi.Pointer<Tox> tox,
    int friend_number,
    ffi.Pointer<ffi.Uint8> data,
    int length,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_friend_send_lossless_packet(
          tox,
          friend_number,
          data,
          length,
          error,
        ) !=
        0;
  }

  late final _tox_friend_send_lossless_packetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint8 Function(
              ffi.Pointer<Tox>,
              ffi.Uint32,
              ffi.Pointer<ffi.Uint8>,
              size_t,
              ffi.Pointer<ffi.Int32>)>>('tox_friend_send_lossless_packet');
  late final _tox_friend_send_lossless_packet =
      _tox_friend_send_lossless_packetPtr.asFunction<
          int Function(ffi.Pointer<Tox>, int, ffi.Pointer<ffi.Uint8>, int,
              ffi.Pointer<ffi.Int32>)>();

  /// Set the callback for the `friend_lossy_packet` event. Pass NULL to unset.
  void tox_callback_friend_lossy_packet(
    ffi.Pointer<Tox> tox,
    ffi.Pointer<tox_friend_lossy_packet_cb> callback,
  ) {
    return _tox_callback_friend_lossy_packet(
      tox,
      callback,
    );
  }

  late final _tox_callback_friend_lossy_packetPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<Tox>, ffi.Pointer<tox_friend_lossy_packet_cb>)>>(
      'tox_callback_friend_lossy_packet');
  late final _tox_callback_friend_lossy_packet =
      _tox_callback_friend_lossy_packetPtr.asFunction<
          void Function(
              ffi.Pointer<Tox>, ffi.Pointer<tox_friend_lossy_packet_cb>)>();

  /// Set the callback for the `friend_lossless_packet` event. Pass NULL to unset.
  void tox_callback_friend_lossless_packet(
    ffi.Pointer<Tox> tox,
    ffi.Pointer<tox_friend_lossless_packet_cb> callback,
  ) {
    return _tox_callback_friend_lossless_packet(
      tox,
      callback,
    );
  }

  late final _tox_callback_friend_lossless_packetPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<Tox>,
                  ffi.Pointer<tox_friend_lossless_packet_cb>)>>(
      'tox_callback_friend_lossless_packet');
  late final _tox_callback_friend_lossless_packet =
      _tox_callback_friend_lossless_packetPtr.asFunction<
          void Function(
              ffi.Pointer<Tox>, ffi.Pointer<tox_friend_lossless_packet_cb>)>();

  /// Writes the temporary DHT public key of this instance to a byte array.
  ///
  /// This can be used in combination with an externally accessible IP address and
  /// the bound port (from tox_self_get_udp_port) to run a temporary bootstrap node.
  ///
  /// Be aware that every time a new instance is created, the DHT public key
  /// changes, meaning this cannot be used to run a permanent bootstrap node.
  ///
  /// @param dht_id A memory region of at least TOX_PUBLIC_KEY_SIZE bytes. If this
  /// parameter is NULL, this function has no effect.
  void tox_self_get_dht_id(
    ffi.Pointer<Tox> tox,
    ffi.Pointer<ffi.Uint8> dht_id,
  ) {
    return _tox_self_get_dht_id(
      tox,
      dht_id,
    );
  }

  late final _tox_self_get_dht_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<Tox>,
              ffi.Pointer<ffi.Uint8>)>>('tox_self_get_dht_id');
  late final _tox_self_get_dht_id = _tox_self_get_dht_idPtr
      .asFunction<void Function(ffi.Pointer<Tox>, ffi.Pointer<ffi.Uint8>)>();

  /// Return the UDP port this Tox instance is bound to.
  int tox_self_get_udp_port(
    ffi.Pointer<Tox> tox,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_self_get_udp_port(
      tox,
      error,
    );
  }

  late final _tox_self_get_udp_portPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint16 Function(ffi.Pointer<Tox>,
              ffi.Pointer<ffi.Int32>)>>('tox_self_get_udp_port');
  late final _tox_self_get_udp_port = _tox_self_get_udp_portPtr
      .asFunction<int Function(ffi.Pointer<Tox>, ffi.Pointer<ffi.Int32>)>();

  /// Return the TCP port this Tox instance is bound to. This is only relevant if
  /// the instance is acting as a TCP relay.
  int tox_self_get_tcp_port(
    ffi.Pointer<Tox> tox,
    ffi.Pointer<ffi.Int32> error,
  ) {
    return _tox_self_get_tcp_port(
      tox,
      error,
    );
  }

  late final _tox_self_get_tcp_portPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint16 Function(ffi.Pointer<Tox>,
              ffi.Pointer<ffi.Int32>)>>('tox_self_get_tcp_port');
  late final _tox_self_get_tcp_port = _tox_self_get_tcp_portPtr
      .asFunction<int Function(ffi.Pointer<Tox>, ffi.Pointer<ffi.Int32>)>();
}

class Tox extends ffi.Opaque {}

/// Represents the possible statuses a client can have.
///
/// @deprecated All UPPER_CASE enum type names are deprecated. Use the
/// Camel_Snake_Case versions, instead.
abstract class Tox_User_Status {
  /// User is online and available.
  static const int TOX_USER_STATUS_NONE = 0;

  /// User is away. Clients can set this e.g. after a user defined
  /// inactivity time.
  static const int TOX_USER_STATUS_AWAY = 1;

  /// User is busy. Signals to other clients that this client does not
  /// currently wish to communicate.
  static const int TOX_USER_STATUS_BUSY = 2;
}

/// Represents message types for tox_friend_send_message and conference
/// messages.
///
/// @deprecated All UPPER_CASE enum type names are deprecated. Use the
/// Camel_Snake_Case versions, instead.
abstract class Tox_Message_Type {
  /// Normal text message. Similar to PRIVMSG on IRC.
  static const int TOX_MESSAGE_TYPE_NORMAL = 0;

  /// A message describing an user action. This is similar to /me (CTCP ACTION)
  /// on IRC.
  static const int TOX_MESSAGE_TYPE_ACTION = 1;
}

/// Type of proxy used to connect to TCP relays.
///
/// @deprecated All UPPER_CASE enum type names are deprecated. Use the
/// Camel_Snake_Case versions, instead.
abstract class Tox_Proxy_Type {
  /// Don't use a proxy.
  static const int TOX_PROXY_TYPE_NONE = 0;

  /// HTTP proxy using CONNECT.
  static const int TOX_PROXY_TYPE_HTTP = 1;

  /// SOCKS proxy for simple socket pipes.
  static const int TOX_PROXY_TYPE_SOCKS5 = 2;
}

/// Type of savedata to create the Tox instance from.
///
/// @deprecated All UPPER_CASE enum type names are deprecated. Use the
/// Camel_Snake_Case versions, instead.
abstract class Tox_Savedata_Type {
  /// No savedata.
  static const int TOX_SAVEDATA_TYPE_NONE = 0;

  /// Savedata is one that was obtained from tox_get_savedata.
  static const int TOX_SAVEDATA_TYPE_TOX_SAVE = 1;

  /// Savedata is a secret key of length TOX_SECRET_KEY_SIZE.
  static const int TOX_SAVEDATA_TYPE_SECRET_KEY = 2;
}

/// Severity level of log messages.
///
/// @deprecated All UPPER_CASE enum type names are deprecated. Use the
/// Camel_Snake_Case versions, instead.
abstract class Tox_Log_Level {
  /// Very detailed traces including all network activity.
  static const int TOX_LOG_LEVEL_TRACE = 0;

  /// Debug messages such as which port we bind to.
  static const int TOX_LOG_LEVEL_DEBUG = 1;

  /// Informational log messages such as video call status changes.
  static const int TOX_LOG_LEVEL_INFO = 2;

  /// Warnings about internal inconsistency or logic errors.
  static const int TOX_LOG_LEVEL_WARNING = 3;

  /// Severe unexpected errors caused by external or internal inconsistency.
  static const int TOX_LOG_LEVEL_ERROR = 4;
}

/// This struct contains all the startup options for Tox. You must tox_options_new to
/// allocate an object of this type.
///
/// WARNING: Although this struct happens to be visible in the API, it is
/// effectively private. Do not allocate this yourself or access members
/// directly, as it *will* break binary compatibility frequently.
///
/// @deprecated The memory layout of this struct (size, alignment, and field
/// order) is not part of the ABI. To remain compatible, prefer to use tox_options_new to
/// allocate the object and accessor functions to set the members. The struct
/// will become opaque (i.e. the definition will become private) in v0.3.0.
class Tox_Options extends ffi.Opaque {}

typedef size_t = ffi.Uint64;

/// This event is triggered when the toxcore library logs an internal message.
/// This is mostly useful for debugging. This callback can be called from any
/// function, not just tox_iterate. This means the user data lifetime must at
/// least extend between registering and unregistering it or tox_kill.
///
/// Other toxcore modules such as toxav may concurrently call this callback at
/// any time. Thus, user code must make sure it is equipped to handle concurrent
/// execution, e.g. by employing appropriate mutex locking.
///
/// @param level The severity of the log message.
/// @param file The source file from which the message originated.
/// @param line The source line from which the message originated.
/// @param func The function from which the message originated.
/// @param message The log message.
/// @param user_data The user data pointer passed to tox_new in options.
typedef tox_log_cb = ffi.NativeFunction<
    ffi.Void Function(
        ffi.Pointer<Tox>,
        ffi.Int32,
        ffi.Pointer<ffi.Int8>,
        ffi.Uint32,
        ffi.Pointer<ffi.Int8>,
        ffi.Pointer<ffi.Int8>,
        ffi.Pointer<ffi.Void>)>;

abstract class Tox_Err_Options_New {
  /// The function returned successfully.
  static const int TOX_ERR_OPTIONS_NEW_OK = 0;

  /// The function failed to allocate enough memory for the options struct.
  static const int TOX_ERR_OPTIONS_NEW_MALLOC = 1;
}

/// :: Creation and destruction
abstract class Tox_Err_New {
  /// The function returned successfully.
  static const int TOX_ERR_NEW_OK = 0;

  /// One of the arguments to the function was NULL when it was not expected.
  static const int TOX_ERR_NEW_NULL = 1;

  /// The function was unable to allocate enough memory to store the internal
  /// structures for the Tox object.
  static const int TOX_ERR_NEW_MALLOC = 2;

  /// The function was unable to bind to a port. This may mean that all ports
  /// have already been bound, e.g. by other Tox instances, or it may mean
  /// a permission error. You may be able to gather more information from errno.
  static const int TOX_ERR_NEW_PORT_ALLOC = 3;

  /// proxy_type was invalid.
  static const int TOX_ERR_NEW_PROXY_BAD_TYPE = 4;

  /// proxy_type was valid but the proxy_host passed had an invalid format
  /// or was NULL.
  static const int TOX_ERR_NEW_PROXY_BAD_HOST = 5;

  /// proxy_type was valid, but the proxy_port was invalid.
  static const int TOX_ERR_NEW_PROXY_BAD_PORT = 6;

  /// The proxy address passed could not be resolved.
  static const int TOX_ERR_NEW_PROXY_NOT_FOUND = 7;

  /// The byte array to be loaded contained an encrypted save.
  static const int TOX_ERR_NEW_LOAD_ENCRYPTED = 8;

  /// The data format was invalid. This can happen when loading data that was
  /// saved by an older version of Tox, or when the data has been corrupted.
  /// When loading from badly formatted data, some data may have been loaded,
  /// and the rest is discarded. Passing an invalid length parameter also
  /// causes this error.
  static const int TOX_ERR_NEW_LOAD_BAD_FORMAT = 9;
}

/// :: Connection lifecycle and event loop
abstract class Tox_Err_Bootstrap {
  /// The function returned successfully.
  static const int TOX_ERR_BOOTSTRAP_OK = 0;

  /// One of the arguments to the function was NULL when it was not expected.
  static const int TOX_ERR_BOOTSTRAP_NULL = 1;

  /// The hostname could not be resolved to an IP address, or the IP address
  /// passed was invalid.
  static const int TOX_ERR_BOOTSTRAP_BAD_HOST = 2;

  /// The port passed was invalid. The valid port range is (1, 65535).
  static const int TOX_ERR_BOOTSTRAP_BAD_PORT = 3;
}

/// Protocols that can be used to connect to the network or friends.
///
/// @deprecated All UPPER_CASE enum type names are deprecated. Use the
/// Camel_Snake_Case versions, instead.
abstract class Tox_Connection {
  /// There is no connection. This instance, or the friend the state change is
  /// about, is now offline.
  static const int TOX_CONNECTION_NONE = 0;

  /// A TCP connection has been established. For the own instance, this means it
  /// is connected through a TCP relay, only. For a friend, this means that the
  /// connection to that particular friend goes through a TCP relay.
  static const int TOX_CONNECTION_TCP = 1;

  /// A UDP connection has been established. For the own instance, this means it
  /// is able to send UDP packets to DHT nodes, but may still be connected to
  /// a TCP relay. For a friend, this means that the connection to that
  /// particular friend was built using direct UDP packets.
  static const int TOX_CONNECTION_UDP = 2;
}

/// @param connection_status Whether we are connected to the DHT.
typedef tox_self_connection_status_cb = ffi.NativeFunction<
    ffi.Void Function(ffi.Pointer<Tox>, ffi.Int32, ffi.Pointer<ffi.Void>)>;

/// Common error codes for all functions that set a piece of user-visible
/// client information.
abstract class Tox_Err_Set_Info {
  /// The function returned successfully.
  static const int TOX_ERR_SET_INFO_OK = 0;

  /// One of the arguments to the function was NULL when it was not expected.
  static const int TOX_ERR_SET_INFO_NULL = 1;

  /// Information length exceeded maximum permissible size.
  static const int TOX_ERR_SET_INFO_TOO_LONG = 2;
}

/// :: Friend list management
abstract class Tox_Err_Friend_Add {
  /// The function returned successfully.
  static const int TOX_ERR_FRIEND_ADD_OK = 0;

  /// One of the arguments to the function was NULL when it was not expected.
  static const int TOX_ERR_FRIEND_ADD_NULL = 1;

  /// The length of the friend request message exceeded
  /// TOX_MAX_FRIEND_REQUEST_LENGTH.
  static const int TOX_ERR_FRIEND_ADD_TOO_LONG = 2;

  /// The friend request message was empty. This, and the TOO_LONG code will
  /// never be returned from tox_friend_add_norequest.
  static const int TOX_ERR_FRIEND_ADD_NO_MESSAGE = 3;

  /// The friend address belongs to the sending client.
  static const int TOX_ERR_FRIEND_ADD_OWN_KEY = 4;

  /// A friend request has already been sent, or the address belongs to a friend
  /// that is already on the friend list.
  static const int TOX_ERR_FRIEND_ADD_ALREADY_SENT = 5;

  /// The friend address checksum failed.
  static const int TOX_ERR_FRIEND_ADD_BAD_CHECKSUM = 6;

  /// The friend was already there, but the nospam value was different.
  static const int TOX_ERR_FRIEND_ADD_SET_NEW_NOSPAM = 7;

  /// A memory allocation failed when trying to increase the friend list size.
  static const int TOX_ERR_FRIEND_ADD_MALLOC = 8;
}

abstract class Tox_Err_Friend_Delete {
  /// The function returned successfully.
  static const int TOX_ERR_FRIEND_DELETE_OK = 0;

  /// There was no friend with the given friend number. No friends were deleted.
  static const int TOX_ERR_FRIEND_DELETE_FRIEND_NOT_FOUND = 1;
}

/// :: Friend list queries
abstract class Tox_Err_Friend_By_Public_Key {
  /// The function returned successfully.
  static const int TOX_ERR_FRIEND_BY_PUBLIC_KEY_OK = 0;

  /// One of the arguments to the function was NULL when it was not expected.
  static const int TOX_ERR_FRIEND_BY_PUBLIC_KEY_NULL = 1;

  /// No friend with the given Public Key exists on the friend list.
  static const int TOX_ERR_FRIEND_BY_PUBLIC_KEY_NOT_FOUND = 2;
}

abstract class Tox_Err_Friend_Get_Public_Key {
  /// The function returned successfully.
  static const int TOX_ERR_FRIEND_GET_PUBLIC_KEY_OK = 0;

  /// No friend with the given number exists on the friend list.
  static const int TOX_ERR_FRIEND_GET_PUBLIC_KEY_FRIEND_NOT_FOUND = 1;
}

abstract class Tox_Err_Friend_Get_Last_Online {
  /// The function returned successfully.
  static const int TOX_ERR_FRIEND_GET_LAST_ONLINE_OK = 0;

  /// No friend with the given number exists on the friend list.
  static const int TOX_ERR_FRIEND_GET_LAST_ONLINE_FRIEND_NOT_FOUND = 1;
}

/// Common error codes for friend state query functions.
abstract class Tox_Err_Friend_Query {
  /// The function returned successfully.
  static const int TOX_ERR_FRIEND_QUERY_OK = 0;

  /// The pointer parameter for storing the query result (name, message) was
  /// NULL. Unlike the `_self_` variants of these functions, which have no effect
  /// when a parameter is NULL, these functions return an error in that case.
  static const int TOX_ERR_FRIEND_QUERY_NULL = 1;

  /// The friend_number did not designate a valid friend.
  static const int TOX_ERR_FRIEND_QUERY_FRIEND_NOT_FOUND = 2;
}

/// @param friend_number The friend number of the friend whose name changed.
/// @param name A byte array containing the same data as
/// tox_friend_get_name would write to its `name` parameter.
/// @param length A value equal to the return value of
/// tox_friend_get_name_size.
typedef tox_friend_name_cb = ffi.NativeFunction<
    ffi.Void Function(ffi.Pointer<Tox>, ffi.Uint32, ffi.Pointer<ffi.Uint8>,
        size_t, ffi.Pointer<ffi.Void>)>;

/// @param friend_number The friend number of the friend whose status message
/// changed.
/// @param message A byte array containing the same data as
/// tox_friend_get_status_message would write to its `status_message` parameter.
/// @param length A value equal to the return value of
/// tox_friend_get_status_message_size.
typedef tox_friend_status_message_cb = ffi.NativeFunction<
    ffi.Void Function(ffi.Pointer<Tox>, ffi.Uint32, ffi.Pointer<ffi.Uint8>,
        size_t, ffi.Pointer<ffi.Void>)>;

/// @param friend_number The friend number of the friend whose user status
/// changed.
/// @param status The new user status.
typedef tox_friend_status_cb = ffi.NativeFunction<
    ffi.Void Function(
        ffi.Pointer<Tox>, ffi.Uint32, ffi.Int32, ffi.Pointer<ffi.Void>)>;

/// @param friend_number The friend number of the friend whose connection status
/// changed.
/// @param connection_status The result of calling
/// tox_friend_get_connection_status on the passed friend_number.
typedef tox_friend_connection_status_cb = ffi.NativeFunction<
    ffi.Void Function(
        ffi.Pointer<Tox>, ffi.Uint32, ffi.Int32, ffi.Pointer<ffi.Void>)>;

/// @param friend_number The friend number of the friend who started or stopped
/// typing.
/// @param is_typing The result of calling tox_friend_get_typing on the passed
/// friend_number.
typedef tox_friend_typing_cb = ffi.NativeFunction<
    ffi.Void Function(
        ffi.Pointer<Tox>, ffi.Uint32, ffi.Uint8, ffi.Pointer<ffi.Void>)>;

/// :: Sending private messages
abstract class Tox_Err_Set_Typing {
  /// The function returned successfully.
  static const int TOX_ERR_SET_TYPING_OK = 0;

  /// The friend number did not designate a valid friend.
  static const int TOX_ERR_SET_TYPING_FRIEND_NOT_FOUND = 1;
}

abstract class Tox_Err_Friend_Send_Message {
  /// The function returned successfully.
  static const int TOX_ERR_FRIEND_SEND_MESSAGE_OK = 0;

  /// One of the arguments to the function was NULL when it was not expected.
  static const int TOX_ERR_FRIEND_SEND_MESSAGE_NULL = 1;

  /// The friend number did not designate a valid friend.
  static const int TOX_ERR_FRIEND_SEND_MESSAGE_FRIEND_NOT_FOUND = 2;

  /// This client is currently not connected to the friend.
  static const int TOX_ERR_FRIEND_SEND_MESSAGE_FRIEND_NOT_CONNECTED = 3;

  /// An allocation error occurred while increasing the send queue size.
  static const int TOX_ERR_FRIEND_SEND_MESSAGE_SENDQ = 4;

  /// Message length exceeded TOX_MAX_MESSAGE_LENGTH.
  static const int TOX_ERR_FRIEND_SEND_MESSAGE_TOO_LONG = 5;

  /// Attempted to send a zero-length message.
  static const int TOX_ERR_FRIEND_SEND_MESSAGE_EMPTY = 6;
}

/// @param friend_number The friend number of the friend who received the message.
/// @param message_id The message ID as returned from tox_friend_send_message
/// corresponding to the message sent.
typedef tox_friend_read_receipt_cb = ffi.NativeFunction<
    ffi.Void Function(
        ffi.Pointer<Tox>, ffi.Uint32, ffi.Uint32, ffi.Pointer<ffi.Void>)>;

/// @param public_key The Public Key of the user who sent the friend request.
/// @param message The message they sent along with the request.
/// @param length The size of the message byte array.
typedef tox_friend_request_cb = ffi.NativeFunction<
    ffi.Void Function(ffi.Pointer<Tox>, ffi.Pointer<ffi.Uint8>,
        ffi.Pointer<ffi.Uint8>, size_t, ffi.Pointer<ffi.Void>)>;

/// @param friend_number The friend number of the friend who sent the message.
/// @param message The message data they sent.
/// @param length The size of the message byte array.
typedef tox_friend_message_cb = ffi.NativeFunction<
    ffi.Void Function(ffi.Pointer<Tox>, ffi.Uint32, ffi.Int32,
        ffi.Pointer<ffi.Uint8>, size_t, ffi.Pointer<ffi.Void>)>;

/// A list of pre-defined file kinds. Toxcore itself does not behave
/// differently for different file kinds. These are a hint to the client
/// telling it what use the sender intended for the file. The `kind` parameter
/// in the send function and recv callback are `uint32_t`, not Tox_File_Kind, because
/// clients can invent their own file kind. Unknown file kinds should be
/// treated as TOX_FILE_KIND_DATA.
abstract class Tox_File_Kind {
  /// Arbitrary file data. Clients can choose to handle it based on the file name
  /// or magic or any other way they choose.
  static const int TOX_FILE_KIND_DATA = 0;

  /// Avatar file_id. This consists of tox_hash(image).
  /// Avatar data. This consists of the image data.
  ///
  /// Avatars can be sent at any time the client wishes. Generally, a client will
  /// send the avatar to a friend when that friend comes online, and to all
  /// friends when the avatar changed. A client can save some traffic by
  /// remembering which friend received the updated avatar already and only send
  /// it if the friend has an out of date avatar.
  ///
  /// Clients who receive avatar send requests can reject it (by sending
  /// TOX_FILE_CONTROL_CANCEL before any other controls), or accept it (by
  /// sending TOX_FILE_CONTROL_RESUME). The file_id of length TOX_HASH_LENGTH bytes
  /// (same length as TOX_FILE_ID_LENGTH) will contain the hash. A client can compare
  /// this hash with a saved hash and send TOX_FILE_CONTROL_CANCEL to terminate the avatar
  /// transfer if it matches.
  ///
  /// When file_size is set to 0 in the transfer request it means that the client
  /// has no avatar.
  static const int TOX_FILE_KIND_AVATAR = 1;
}

abstract class Tox_File_Control {
  /// Sent by the receiving side to accept a file send request. Also sent after a
  /// TOX_FILE_CONTROL_PAUSE command to continue sending or receiving.
  static const int TOX_FILE_CONTROL_RESUME = 0;

  /// Sent by clients to pause the file transfer. The initial state of a file
  /// transfer is always paused on the receiving side and running on the sending
  /// side. If both the sending and receiving side pause the transfer, then both
  /// need to send TOX_FILE_CONTROL_RESUME for the transfer to resume.
  static const int TOX_FILE_CONTROL_PAUSE = 1;

  /// Sent by the receiving side to reject a file send request before any other
  /// commands are sent. Also sent by either side to terminate a file transfer.
  static const int TOX_FILE_CONTROL_CANCEL = 2;
}

abstract class Tox_Err_File_Control {
  /// The function returned successfully.
  static const int TOX_ERR_FILE_CONTROL_OK = 0;

  /// The friend_number passed did not designate a valid friend.
  static const int TOX_ERR_FILE_CONTROL_FRIEND_NOT_FOUND = 1;

  /// This client is currently not connected to the friend.
  static const int TOX_ERR_FILE_CONTROL_FRIEND_NOT_CONNECTED = 2;

  /// No file transfer with the given file number was found for the given friend.
  static const int TOX_ERR_FILE_CONTROL_NOT_FOUND = 3;

  /// A RESUME control was sent, but the file transfer is running normally.
  static const int TOX_ERR_FILE_CONTROL_NOT_PAUSED = 4;

  /// A RESUME control was sent, but the file transfer was paused by the other
  /// party. Only the party that paused the transfer can resume it.
  static const int TOX_ERR_FILE_CONTROL_DENIED = 5;

  /// A PAUSE control was sent, but the file transfer was already paused.
  static const int TOX_ERR_FILE_CONTROL_ALREADY_PAUSED = 6;

  /// Packet queue is full.
  static const int TOX_ERR_FILE_CONTROL_SENDQ = 7;
}

/// When receiving TOX_FILE_CONTROL_CANCEL, the client should release the
/// resources associated with the file number and consider the transfer failed.
///
/// @param friend_number The friend number of the friend who is sending the file.
/// @param file_number The friend-specific file number the data received is
/// associated with.
/// @param control The file control command received.
typedef tox_file_recv_control_cb = ffi.NativeFunction<
    ffi.Void Function(ffi.Pointer<Tox>, ffi.Uint32, ffi.Uint32, ffi.Int32,
        ffi.Pointer<ffi.Void>)>;

abstract class Tox_Err_File_Seek {
  /// The function returned successfully.
  static const int TOX_ERR_FILE_SEEK_OK = 0;

  /// The friend_number passed did not designate a valid friend.
  static const int TOX_ERR_FILE_SEEK_FRIEND_NOT_FOUND = 1;

  /// This client is currently not connected to the friend.
  static const int TOX_ERR_FILE_SEEK_FRIEND_NOT_CONNECTED = 2;

  /// No file transfer with the given file number was found for the given friend.
  static const int TOX_ERR_FILE_SEEK_NOT_FOUND = 3;

  /// File was not in a state where it could be seeked.
  static const int TOX_ERR_FILE_SEEK_DENIED = 4;

  /// Seek position was invalid
  static const int TOX_ERR_FILE_SEEK_INVALID_POSITION = 5;

  /// Packet queue is full.
  static const int TOX_ERR_FILE_SEEK_SENDQ = 6;
}

abstract class Tox_Err_File_Get {
  /// The function returned successfully.
  static const int TOX_ERR_FILE_GET_OK = 0;

  /// One of the arguments to the function was NULL when it was not expected.
  static const int TOX_ERR_FILE_GET_NULL = 1;

  /// The friend_number passed did not designate a valid friend.
  static const int TOX_ERR_FILE_GET_FRIEND_NOT_FOUND = 2;

  /// No file transfer with the given file number was found for the given friend.
  static const int TOX_ERR_FILE_GET_NOT_FOUND = 3;
}

/// :: File transmission: sending
abstract class Tox_Err_File_Send {
  /// The function returned successfully.
  static const int TOX_ERR_FILE_SEND_OK = 0;

  /// One of the arguments to the function was NULL when it was not expected.
  static const int TOX_ERR_FILE_SEND_NULL = 1;

  /// The friend_number passed did not designate a valid friend.
  static const int TOX_ERR_FILE_SEND_FRIEND_NOT_FOUND = 2;

  /// This client is currently not connected to the friend.
  static const int TOX_ERR_FILE_SEND_FRIEND_NOT_CONNECTED = 3;

  /// Filename length exceeded TOX_MAX_FILENAME_LENGTH bytes.
  static const int TOX_ERR_FILE_SEND_NAME_TOO_LONG = 4;

  /// Too many ongoing transfers. The maximum number of concurrent file transfers
  /// is 256 per friend per direction (sending and receiving).
  static const int TOX_ERR_FILE_SEND_TOO_MANY = 5;
}

abstract class Tox_Err_File_Send_Chunk {
  /// The function returned successfully.
  static const int TOX_ERR_FILE_SEND_CHUNK_OK = 0;

  /// The length parameter was non-zero, but data was NULL.
  static const int TOX_ERR_FILE_SEND_CHUNK_NULL = 1;

  /// The friend_number passed did not designate a valid friend.
  static const int TOX_ERR_FILE_SEND_CHUNK_FRIEND_NOT_FOUND = 2;

  /// This client is currently not connected to the friend.
  static const int TOX_ERR_FILE_SEND_CHUNK_FRIEND_NOT_CONNECTED = 3;

  /// No file transfer with the given file number was found for the given friend.
  static const int TOX_ERR_FILE_SEND_CHUNK_NOT_FOUND = 4;

  /// File transfer was found but isn't in a transferring state: (paused, done,
  /// broken, etc...) (happens only when not called from the request chunk callback).
  static const int TOX_ERR_FILE_SEND_CHUNK_NOT_TRANSFERRING = 5;

  /// Attempted to send more or less data than requested. The requested data size is
  /// adjusted according to maximum transmission unit and the expected end of
  /// the file. Trying to send less or more than requested will return this error.
  static const int TOX_ERR_FILE_SEND_CHUNK_INVALID_LENGTH = 6;

  /// Packet queue is full.
  static const int TOX_ERR_FILE_SEND_CHUNK_SENDQ = 7;

  /// Position parameter was wrong.
  static const int TOX_ERR_FILE_SEND_CHUNK_WRONG_POSITION = 8;
}

/// If the length parameter is 0, the file transfer is finished, and the client's
/// resources associated with the file number should be released. After a call
/// with zero length, the file number can be reused for future file transfers.
///
/// If the requested position is not equal to the client's idea of the current
/// file or stream position, it will need to seek. In case of read-once streams,
/// the client should keep the last read chunk so that a seek back can be
/// supported. A seek-back only ever needs to read from the last requested chunk.
/// This happens when a chunk was requested, but the send failed. A seek-back
/// request can occur an arbitrary number of times for any given chunk.
///
/// In response to receiving this callback, the client should call the function
/// `tox_file_send_chunk` with the requested chunk. If the number of bytes sent
/// through that function is zero, the file transfer is assumed complete. A
/// client must send the full length of data requested with this callback.
///
/// @param friend_number The friend number of the receiving friend for this file.
/// @param file_number The file transfer identifier returned by tox_file_send.
/// @param position The file or stream position from which to continue reading.
/// @param length The number of bytes requested for the current chunk.
typedef tox_file_chunk_request_cb = ffi.NativeFunction<
    ffi.Void Function(ffi.Pointer<Tox>, ffi.Uint32, ffi.Uint32, ffi.Uint64,
        size_t, ffi.Pointer<ffi.Void>)>;

/// The client should acquire resources to be associated with the file transfer.
/// Incoming file transfers start in the PAUSED state. After this callback
/// returns, a transfer can be rejected by sending a TOX_FILE_CONTROL_CANCEL
/// control command before any other control commands. It can be accepted by
/// sending TOX_FILE_CONTROL_RESUME.
///
/// @param friend_number The friend number of the friend who is sending the file
/// transfer request.
/// @param file_number The friend-specific file number the data received is
/// associated with.
/// @param kind The meaning of the file that was sent.
/// @param file_size Size in bytes of the file the client wants to send,
/// UINT64_MAX if unknown or streaming.
/// @param filename Name of the file. Does not need to be the actual name. This
/// name will be sent along with the file send request.
/// @param filename_length Size in bytes of the filename.
typedef tox_file_recv_cb = ffi.NativeFunction<
    ffi.Void Function(ffi.Pointer<Tox>, ffi.Uint32, ffi.Uint32, ffi.Uint32,
        ffi.Uint64, ffi.Pointer<ffi.Uint8>, size_t, ffi.Pointer<ffi.Void>)>;

/// When length is 0, the transfer is finished and the client should release the
/// resources it acquired for the transfer. After a call with length = 0, the
/// file number can be reused for new file transfers.
///
/// If position is equal to file_size (received in the file_receive callback)
/// when the transfer finishes, the file was received completely. Otherwise, if
/// file_size was UINT64_MAX, streaming ended successfully when length is 0.
///
/// @param friend_number The friend number of the friend who is sending the file.
/// @param file_number The friend-specific file number the data received is
/// associated with.
/// @param position The file position of the first byte in data.
/// @param data A byte array containing the received chunk.
/// @param length The length of the received chunk.
typedef tox_file_recv_chunk_cb = ffi.NativeFunction<
    ffi.Void Function(ffi.Pointer<Tox>, ffi.Uint32, ffi.Uint32, ffi.Uint64,
        ffi.Pointer<ffi.Uint8>, size_t, ffi.Pointer<ffi.Void>)>;

/// Conference types for the conference_invite event.
///
/// @deprecated All UPPER_CASE enum type names are deprecated. Use the
/// Camel_Snake_Case versions, instead.
abstract class Tox_Conference_Type {
  /// Text-only conferences that must be accepted with the tox_conference_join function.
  static const int TOX_CONFERENCE_TYPE_TEXT = 0;

  /// Video conference. The function to accept these is in toxav.
  static const int TOX_CONFERENCE_TYPE_AV = 1;
}

/// The invitation will remain valid until the inviting friend goes offline
/// or exits the conference.
///
/// @param friend_number The friend who invited us.
/// @param type The conference type (text only or audio/video).
/// @param cookie A piece of data of variable length required to join the
/// conference.
/// @param length The length of the cookie.
typedef tox_conference_invite_cb = ffi.NativeFunction<
    ffi.Void Function(ffi.Pointer<Tox>, ffi.Uint32, ffi.Int32,
        ffi.Pointer<ffi.Uint8>, size_t, ffi.Pointer<ffi.Void>)>;

/// @param conference_number The conference number of the conference to which we have connected.
typedef tox_conference_connected_cb = ffi.NativeFunction<
    ffi.Void Function(ffi.Pointer<Tox>, ffi.Uint32, ffi.Pointer<ffi.Void>)>;

/// @param conference_number The conference number of the conference the message is intended for.
/// @param peer_number The ID of the peer who sent the message.
/// @param type The type of message (normal, action, ...).
/// @param message The message data.
/// @param length The length of the message.
typedef tox_conference_message_cb = ffi.NativeFunction<
    ffi.Void Function(ffi.Pointer<Tox>, ffi.Uint32, ffi.Uint32, ffi.Int32,
        ffi.Pointer<ffi.Uint8>, size_t, ffi.Pointer<ffi.Void>)>;

/// @param conference_number The conference number of the conference the title change is intended for.
/// @param peer_number The ID of the peer who changed the title.
/// @param title The title data.
/// @param length The title length.
typedef tox_conference_title_cb = ffi.NativeFunction<
    ffi.Void Function(ffi.Pointer<Tox>, ffi.Uint32, ffi.Uint32,
        ffi.Pointer<ffi.Uint8>, size_t, ffi.Pointer<ffi.Void>)>;

/// @param conference_number The conference number of the conference the
/// peer is in.
/// @param peer_number The ID of the peer who changed their nickname.
/// @param name A byte array containing the new nickname.
/// @param length The size of the name byte array.
typedef tox_conference_peer_name_cb = ffi.NativeFunction<
    ffi.Void Function(ffi.Pointer<Tox>, ffi.Uint32, ffi.Uint32,
        ffi.Pointer<ffi.Uint8>, size_t, ffi.Pointer<ffi.Void>)>;

/// @param conference_number The conference number of the conference the
/// peer is in.
typedef tox_conference_peer_list_changed_cb = ffi.NativeFunction<
    ffi.Void Function(ffi.Pointer<Tox>, ffi.Uint32, ffi.Pointer<ffi.Void>)>;

abstract class Tox_Err_Conference_New {
  /// The function returned successfully.
  static const int TOX_ERR_CONFERENCE_NEW_OK = 0;

  /// The conference instance failed to initialize.
  static const int TOX_ERR_CONFERENCE_NEW_INIT = 1;
}

abstract class Tox_Err_Conference_Delete {
  /// The function returned successfully.
  static const int TOX_ERR_CONFERENCE_DELETE_OK = 0;

  /// The conference number passed did not designate a valid conference.
  static const int TOX_ERR_CONFERENCE_DELETE_CONFERENCE_NOT_FOUND = 1;
}

/// Error codes for peer info queries.
abstract class Tox_Err_Conference_Peer_Query {
  /// The function returned successfully.
  static const int TOX_ERR_CONFERENCE_PEER_QUERY_OK = 0;

  /// The conference number passed did not designate a valid conference.
  static const int TOX_ERR_CONFERENCE_PEER_QUERY_CONFERENCE_NOT_FOUND = 1;

  /// The peer number passed did not designate a valid peer.
  static const int TOX_ERR_CONFERENCE_PEER_QUERY_PEER_NOT_FOUND = 2;

  /// The client is not connected to the conference.
  static const int TOX_ERR_CONFERENCE_PEER_QUERY_NO_CONNECTION = 3;
}

abstract class Tox_Err_Conference_Set_Max_Offline {
  /// The function returned successfully.
  static const int TOX_ERR_CONFERENCE_SET_MAX_OFFLINE_OK = 0;

  /// The conference number passed did not designate a valid conference.
  static const int TOX_ERR_CONFERENCE_SET_MAX_OFFLINE_CONFERENCE_NOT_FOUND = 1;
}

abstract class Tox_Err_Conference_Invite {
  /// The function returned successfully.
  static const int TOX_ERR_CONFERENCE_INVITE_OK = 0;

  /// The conference number passed did not designate a valid conference.
  static const int TOX_ERR_CONFERENCE_INVITE_CONFERENCE_NOT_FOUND = 1;

  /// The invite packet failed to send.
  static const int TOX_ERR_CONFERENCE_INVITE_FAIL_SEND = 2;

  /// The client is not connected to the conference.
  static const int TOX_ERR_CONFERENCE_INVITE_NO_CONNECTION = 3;
}

abstract class Tox_Err_Conference_Join {
  /// The function returned successfully.
  static const int TOX_ERR_CONFERENCE_JOIN_OK = 0;

  /// The cookie passed has an invalid length.
  static const int TOX_ERR_CONFERENCE_JOIN_INVALID_LENGTH = 1;

  /// The conference is not the expected type. This indicates an invalid cookie.
  static const int TOX_ERR_CONFERENCE_JOIN_WRONG_TYPE = 2;

  /// The friend number passed does not designate a valid friend.
  static const int TOX_ERR_CONFERENCE_JOIN_FRIEND_NOT_FOUND = 3;

  /// Client is already in this conference.
  static const int TOX_ERR_CONFERENCE_JOIN_DUPLICATE = 4;

  /// Conference instance failed to initialize.
  static const int TOX_ERR_CONFERENCE_JOIN_INIT_FAIL = 5;

  /// The join packet failed to send.
  static const int TOX_ERR_CONFERENCE_JOIN_FAIL_SEND = 6;
}

abstract class Tox_Err_Conference_Send_Message {
  /// The function returned successfully.
  static const int TOX_ERR_CONFERENCE_SEND_MESSAGE_OK = 0;

  /// The conference number passed did not designate a valid conference.
  static const int TOX_ERR_CONFERENCE_SEND_MESSAGE_CONFERENCE_NOT_FOUND = 1;

  /// The message is too long.
  static const int TOX_ERR_CONFERENCE_SEND_MESSAGE_TOO_LONG = 2;

  /// The client is not connected to the conference.
  static const int TOX_ERR_CONFERENCE_SEND_MESSAGE_NO_CONNECTION = 3;

  /// The message packet failed to send.
  static const int TOX_ERR_CONFERENCE_SEND_MESSAGE_FAIL_SEND = 4;
}

abstract class Tox_Err_Conference_Title {
  /// The function returned successfully.
  static const int TOX_ERR_CONFERENCE_TITLE_OK = 0;

  /// The conference number passed did not designate a valid conference.
  static const int TOX_ERR_CONFERENCE_TITLE_CONFERENCE_NOT_FOUND = 1;

  /// The title is too long or empty.
  static const int TOX_ERR_CONFERENCE_TITLE_INVALID_LENGTH = 2;

  /// The title packet failed to send.
  static const int TOX_ERR_CONFERENCE_TITLE_FAIL_SEND = 3;
}

/// Returns the type of conference (Tox_Conference_Type) that conference_number is. Return value is
/// unspecified on failure.
abstract class Tox_Err_Conference_Get_Type {
  /// The function returned successfully.
  static const int TOX_ERR_CONFERENCE_GET_TYPE_OK = 0;

  /// The conference number passed did not designate a valid conference.
  static const int TOX_ERR_CONFERENCE_GET_TYPE_CONFERENCE_NOT_FOUND = 1;
}

abstract class Tox_Err_Conference_By_Id {
  /// The function returned successfully.
  static const int TOX_ERR_CONFERENCE_BY_ID_OK = 0;

  /// One of the arguments to the function was NULL when it was not expected.
  static const int TOX_ERR_CONFERENCE_BY_ID_NULL = 1;

  /// No conference with the given id exists on the conference list.
  static const int TOX_ERR_CONFERENCE_BY_ID_NOT_FOUND = 2;
}

abstract class Tox_Err_Conference_By_Uid {
  /// The function returned successfully.
  static const int TOX_ERR_CONFERENCE_BY_UID_OK = 0;

  /// One of the arguments to the function was NULL when it was not expected.
  static const int TOX_ERR_CONFERENCE_BY_UID_NULL = 1;

  /// No conference with the given uid exists on the conference list.
  static const int TOX_ERR_CONFERENCE_BY_UID_NOT_FOUND = 2;
}

/// :: Low-level custom packet sending and receiving
abstract class Tox_Err_Friend_Custom_Packet {
  /// The function returned successfully.
  static const int TOX_ERR_FRIEND_CUSTOM_PACKET_OK = 0;

  /// One of the arguments to the function was NULL when it was not expected.
  static const int TOX_ERR_FRIEND_CUSTOM_PACKET_NULL = 1;

  /// The friend number did not designate a valid friend.
  static const int TOX_ERR_FRIEND_CUSTOM_PACKET_FRIEND_NOT_FOUND = 2;

  /// This client is currently not connected to the friend.
  static const int TOX_ERR_FRIEND_CUSTOM_PACKET_FRIEND_NOT_CONNECTED = 3;

  /// The first byte of data was not in the specified range for the packet type.
  /// This range is 192-254 for lossy, and 69, 160-191 for lossless packets.
  static const int TOX_ERR_FRIEND_CUSTOM_PACKET_INVALID = 4;

  /// Attempted to send an empty packet.
  static const int TOX_ERR_FRIEND_CUSTOM_PACKET_EMPTY = 5;

  /// Packet data length exceeded TOX_MAX_CUSTOM_PACKET_SIZE.
  static const int TOX_ERR_FRIEND_CUSTOM_PACKET_TOO_LONG = 6;

  /// Packet queue is full.
  static const int TOX_ERR_FRIEND_CUSTOM_PACKET_SENDQ = 7;
}

/// @param friend_number The friend number of the friend who sent a lossy packet.
/// @param data A byte array containing the received packet data.
/// @param length The length of the packet data byte array.
typedef tox_friend_lossy_packet_cb = ffi.NativeFunction<
    ffi.Void Function(ffi.Pointer<Tox>, ffi.Uint32, ffi.Pointer<ffi.Uint8>,
        size_t, ffi.Pointer<ffi.Void>)>;

/// @param friend_number The friend number of the friend who sent the packet.
/// @param data A byte array containing the received packet data.
/// @param length The length of the packet data byte array.
typedef tox_friend_lossless_packet_cb = ffi.NativeFunction<
    ffi.Void Function(ffi.Pointer<Tox>, ffi.Uint32, ffi.Pointer<ffi.Uint8>,
        size_t, ffi.Pointer<ffi.Void>)>;

/// :: Low-level network information
abstract class Tox_Err_Get_Port {
  /// The function returned successfully.
  static const int TOX_ERR_GET_PORT_OK = 0;

  /// The instance was not bound to any port.
  static const int TOX_ERR_GET_PORT_NOT_BOUND = 1;
}

const int TOX_VERSION_MAJOR = 0;

const int TOX_VERSION_MINOR = 2;

const int TOX_VERSION_PATCH = 13;

const int TOX_PUBLIC_KEY_SIZE = 32;

const int TOX_SECRET_KEY_SIZE = 32;

const int TOX_CONFERENCE_UID_SIZE = 32;

const int TOX_CONFERENCE_ID_SIZE = 32;

const int TOX_NOSPAM_SIZE = 4;

const int TOX_ADDRESS_SIZE = 38;

const int TOX_MAX_NAME_LENGTH = 128;

const int TOX_MAX_STATUS_MESSAGE_LENGTH = 1007;

const int TOX_MAX_FRIEND_REQUEST_LENGTH = 1016;

const int TOX_MAX_MESSAGE_LENGTH = 1372;

const int TOX_MAX_CUSTOM_PACKET_SIZE = 1373;

const int TOX_HASH_LENGTH = 32;

const int TOX_FILE_ID_LENGTH = 32;

const int TOX_MAX_FILENAME_LENGTH = 255;

const int TOX_MAX_HOSTNAME_LENGTH = 255;
